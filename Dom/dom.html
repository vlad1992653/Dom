<!DOCTYPE html>
<html>
	<head>
		 <meta charset="UTF-8"/>
		 <title>Основы работы с DOM</title>
		 <link href="style_dom.css" rel="stylesheet" type="text/css"/>
		 <script src="script.js"></script>
		<script>
		//module.func2();
		</script>
		
	</head>
	<body>
<!-- ваш html код -->
<h3>181 Получение DOM элементов</h3><!-- 152 Получение DOM элементов -->
<!-- 1_ -->
	<input id="button" type="submit"><!-- Создаем инпут  конпкой -->
<!-- 2_ -->
	<div id="parent">
	<input value="1">
	<input value="2">
</div>
<!-- 3_ -->
	<div>
	<input class="elem"/><!-- Создаем инпут  полем ввода -->
	</div>

<h3>182 Привязывание обработчиков событий к элементам </h3><!-- 153 Привязывание обработчиков событий к элементам -->
<!-- 1_ -->
<input id="button1" type="submit"><!-- Создаем инпут с конпкой -->

<h3>183 Другие типы событий </h3><!-- 154 Другие типы событий -->
<input id="button2" type="submit"><!-- Создаем инпут с конпкой -->
<input id="button3" type="submit"><!-- Создаем инпут с конпкой -->
<input id="button4" type="submit"><!-- Создаем инпут с конпкой -->

<h3>184 Именованные обработчики событий </h3><!-- 155 Именованные обработчики событий -->
<input id="button5" type="submit">

<h3>185 Привязывание одного обработчика ко многим элементам</h3><!-- 156 Привязывание одного обработчика ко многим элементам -->
<input id="button6" type="submit" value="button6"><!-- Создаем инпут с конпкой -->
<input id="button7" type="submit" value="button7"><!-- Создаем инпут с конпкой -->

<p id="elem1">text</p><!-- Создаем текст параграфа -->
<p id="elem2">text</p><!-- Создаем текст параграфа -->
<p id="elem3">text</p><!-- Создаем текст параграфа -->
<p id="elem4">text</p><!-- Создаем текст параграфа -->
<p id="elem5">text</p><!-- Создаем текст параграфа -->

<h3>186 Несколько обработчиков одного события</h3><!-- 157 Несколько обработчиков одного события -->
<input id="button8" type="submit"><!-- Создаем инпут с конпкой -->

<h3>187 Работа с текстом тега</h3><!-- 158 Работа с текстом тега -->
<p id="elem6">text</p><!-- Создаем текст параграфа -->
<input id="button9" type="submit"><!-- Создаем инпут с конпкой -->
<p id="elem7">text</p><!-- Создаем текст параграфа -->
<input id="button10" type="submit"><!-- Создаем инпут с конпкой -->

<h3>188 Работа с атрибутами тегов через свойства элементов</h3><!-- 159 Работа с атрибутами тегов через свойства элементов -->
<input id="elem159" type="text"><!-- создаем импут поле ввода  -->
<input id="button159" type="submit"> <hr/> <!-- <hr> используются для создания горизонтальной линии в HTML странице. -->

<input id="elem159_1" type="text"> + <input id="elem159_2" type="text"><!-- создаем импуты 2 поля ввода  -->
<input id="button159_1_2" type="submit"value="Сложить"> <h5>результат =</h5> <!-- Создаем инпут с конпкой -->
<input id="elem159_3" type="text"><hr/><!-- создаем импут поле ввода  -->

<input id="elem159_4" type="email"><!-- создаем импут поле ввода  -->
<input id="button159_1" type="submit"value="Сложить"> <hr/><!-- Создаем инпут с конпкой -->

<a href ="http://ruseller.com">Ссылка на Ruseller.com</a><!-- ссылка на сайт -->
<input id="button159_2" type="submit"value="Ссылка"> <!-- Создаем инпут с конпкой -->
 <p id="elem159_5">обучающий портал</p> <hr/><!-- тег параграфа -->

<img id="elem159_6" src="JS.jpg" alt="JS" /><!-- создаем рисунок -->
<input id="button159_3" type="submit"value="Уменьшить"> <!-- Создаем инпут с конпкой -->
<input id="button159_4" type="submit"value="Увеличить"> <!-- Создаем инпут с конпкой -->

		
<h3>189 Работа с текстовыми полями</h3><!-- 160 Работа с текстовыми полями -->
<input id="elem160_1" type="text"/><!-- создаем импут поле ввода -->
<input id="button160_1" type="submit"value="Изменить"> <!-- Создаем инпут с конпкой -->

<h3>190 Фокус текстовых полей</h3><!-- 161 Фокус текстовых полей-->
<input id="elem161_1" value="text">

<h3>191 Исключения при работе с атрибутами</h3><!-- 162 Исключения при работе с атрибутами-->
<input id="elem162_1" class="aaa bbb"><!-- создаем импут поле ввода -->
<input id="button162_1" type="submit"value="Вывести класс "><!-- Создаем инпут с конпкой -->

<h3>192 Цепочки методов и свойств</h3><!-- 163 Цепочки методов и свойств-->
<input id="elem163_1" value="text"><!-- создаем импут поле ввода -->
<input id="button163_1" type="submit"value="вывод значение поля "><!-- Создаем инпут с конпкой -->


<h3>193 Объект this</h3><!-- 164 Объект this-->
<input id="elem164_1" value="text">

<input id="button164_1" type="submit" value="text1">
<input id="button164_2" type="submit" value="text2">
<input id="button164_3" type="submit" value="text3">

<h3>194 Получение группы элементов</h3><!-- 165 Получение группы элементов -->

<p class="www165">text165_1</p><!-- тег параграфа -->
<p class="www165">text165_2</p><!-- тег параграфа -->
<p class="www165">text165_3</p><!-- тег параграфа -->

<h3>195 Добавление обработчиков событий в цикле</h3><!-- 166 Добавление обработчиков событий в цикле -->
<p class ="www166">text1</p><!-- тег параграфа -->
<p class ="www166">text2</p><!-- тег параграфа -->
<p class ="www166">text3</p><!-- тег параграфа -->

<h3>196 Отвязывание событий через removeEventListener</h3><!-- 167 Отвязывание событий через removeEventListener -->
<input id="button167" type="submit">

<h3>197 Отвязывание обработчиков событий в цикле</h3><!-- 168 Отвязывание обработчиков событий в цикле-->
<p class="colored168">text168_1</p><!-- тег параграфа -->
<p class="colored168">text168_2</p><!-- тег параграфа -->
<p class="colored168">text168_3</p><!-- тег параграфа -->

<h3>198 Отвязывание анонимных функций</h3><!-- 169 Отвязывание анонимных функций-->
<p class="colored169"> text169_1</p><!-- тег параграфа -->
<p class="colored169">text169_2</p><!-- тег параграфа -->
<p class="colored169">text169_3</p><!-- тег параграфа -->

<h3>199 Работа с атрибутами через методы</h3><!-- 170 Работа с атрибутами через методы-->
<input id="elem170" class="" value="abcde">
<input id="button170" type="submit" value="Вывод в уонсоль">

<h3>200 Разница между способами получения атрибутов</h3><!-- 171 Разница между способами получения атрибутов-->
<input id="elem171" class="" value="С НОВЫМ 2022 ГОДОМ !!!">
<input id="button171" type="submit" value="изменить стиль">

<h3>201 Манипулирование CSS классами в JavaScript</h3><!-- 172 Манипулирование CSS классами в JavaScript-->
<p id="elem172" class="www ggg zzz">www ggg zzz</p><!-- тег параграфа  -->
<!-- 172_1 Метод add свойства classList-->
<p id="elem172_1" class="www ggg zzz">172_1 в лесу родилась елочка</p><!-- тег параграфа  -->
<!-- 172_2 Метод remove свойства classList удаляет заданный CSS класс элемента-->
<p id="elem172_2" class="www ggg zzz kkk">172_2 в лесу она росла</p><!-- тег параграфа  -->
<!-- 172_3 Метод contains свойства classList проверяет наличие CSS класса элемента-->
<p id="elem172_3" class="www ggg zzz kkk">172_3 зимой и летом стройная</p><!-- тег параграфа  -->
<!-- 172_4 Метод toggle свойства classList чередует заданный CSS класс элемента-->
<p id="elem172_4" class="www ggg zzz kkk">172_4 зеленая была</p><!-- тег параграфа  -->

<h3>202 Стилизация элементов через атрибут style</h3><!-- 173 Стилизация элементов через атрибут style-->
<!-- 173 Стилизация элементов через атрибут style-->
<p id="elem173" class="ggg zzz kkk">173 стиль в html</p><!-- тег параграфа  -->

<h3>203 Стилизация с помощью CSS классов</h3><!-- 174 Стилизация с помощью CSS классов-->
<!-- 174 Стилизация с помощью CSS классов-->
<p class="colored">text1</p><!-- тег параграфа  -->
<p class="colored">text2</p><!-- тег параграфа  -->
<p class="colored">text3</p><!-- тег параграфа  -->

<button id="button174_1">click me</button>
<div id="elem174_1">wewewe</div>

<h3>204 Нахождение элементов по родственным связям </h3><!-- 175 Нахождение элементов по родственным связям -->
<!-- 175 Нахождение элементов по родственным связям -->
<!-- Свойство firstElementChild -->
<div id="parent175_1"><!-- тег области -->
	<p>1</p><!-- тег параграфа  -->
	<p>2</p><!-- тег параграфа  -->
</div>

<!-- Свойство lastElementChild -->
<div id="parent175_2"><!-- тег области -->
	<p>1</p><!-- тег параграфа  -->
	<p>2</p><!-- тег параграфа  -->
	<p>3</p><!-- тег параграфа  -->
</div>

<!-- Свойство children -->
<div id="parent175_3"><!-- тег области -->
	<p>1</p><!-- тег параграфа  -->
	<p>2</p><!-- тег параграфа  -->
	<p>3</p><!-- тег параграфа  -->
	<p>4</p><!-- тег параграфа  -->
	<p>5</p><!-- тег параграфа  -->
</div>

<!-- Свойство parentElement -->
<div id="parent175_4"><!-- тег области -->
	<p id="elem175_4"></p><!-- тег параграфа  -->
</div>

<!-- метод closest -->
<div class="www175_5" id="parent175_5_2"><!-- тег области -->
	<div class="ggg175_5" id="parent175_5_1"><!-- тег области -->
		<p class="zzz175_5" id="child175_5_1"></p><!-- тег параграфа  -->
	</div>
</div>

<!-- cвойство previousElementSibling -->
<p> 204_6 cвойство previousElementSibling</p><!-- тег параграфа  -->
<p id = "elem175_6" > _____________________</p><!-- тег параграфа  -->

<!-- Свойство nextElementSibling -->
<p id = "elem175_7" > _____________________</p><!-- тег параграфа  -->
<p> 204_7 cвойство nextElementSibling</p><!-- тег параграфа  -->

<h3>205 Другие полезные методы для поиска элементов </h3><!-- 176 Другие полезные методы для поиска элементов  -->

<!-- 176_1 Метод getElementById -->
<input id="elem176_1" value="???"><!-- поле ввода-->

<!-- 176_2 Метод getElementsByTagName -->
<p>elem 1</p><!-- тег параграфа  -->
<p>elem 2</p><!-- тег параграфа  -->
<p>elem 3</p><!-- тег параграфа  -->

<!-- 176_3 Метод getElementsByClassName -->
<p class="www176_3">elem 1</p><!-- тег параграфа  -->
<p class="www176_3">elem 2</p><!-- тег параграфа  -->
<p class="www176_3">elem 3</p><!-- тег параграфа  -->


<h3>206 Поиск элементов внутри другого элемента</h3><!-- 177 Поиск элементов внутри другого элемента-->
<div id="parent177"><!-- тег области -->
	<p class="child177">text1</p><!-- тег параграфа  -->
	<p class="child177">text2</p><!-- тег параграфа  -->
	<p class="child177">text3</p><!-- тег параграфа  -->
	
<h3>207 Пользовательские атрибуты</h3><!-- 178 Пользовательские атрибуты-->
	<div id="elem178" data-num="1000"></div>
</div>

<h3>208 Работа с узлами </h3><!-- 179 Работа с узлами-->
<div id="elem179"><!--сomm-->Казань<span>-1</span>
<p id="elem179_1">1</p><!-- тег параграфа  -->
<p id="elem179_2">2</p><!-- тег параграфа  -->
</div><!-- тег области (с вложенным комментарием, текстом и тегом span) -->

<h3>211_1 Отработка изученного материала </h3><!-- 180_1 Отработка изученного материала-->
<input id="elem180_1" value="345345"><!-- поле ввода-->
<p id="paragraph180_1">1111</p><!-- тег абзаца  -->

<h3>211_2 Отработка изученного материала </h3><!-- 180_1 Отработка изученного материала-->
<input class="child180_2" value="3"><!-- поле ввода-->
<input class="child180_2" value="2"><!-- поле ввода-->
<input class="child180_2" value="1"><!-- поле ввода-->
<input id="button180_2" type="submit"value="Сумма "><br/>
<input id="elem180_22" value=""><!-- поле ввода-->

<h3>211_3 Отработка изученного материала </h3>
<input id="elem180_3" value="12345"><!-- поле ввода-->

<h3>211_4 Отработка изученного материала </h3>
<input id="elem180_4" value="1,2,3,4,5"><!-- поле ввода-->

<h3>211_5 Отработка изученного материала </h3>
<input id="person180_5" value="ФИО полностью"><hr/><!-- поле ввода-->
<input class="child180_5" value="Фамилия"><!-- поле ввода-->
<input class="child180_5" value="Имя"><!-- поле ввода-->
<input class="child180_5" value="Отчество"><!-- поле ввода-->

<h3>211_8 Отработка изученного материала </h3>
<input id="data180_8" value="31.12.2016"><hr/><!-- поле ввода-->

<h3>211_9 Отработка изученного материала </h3>
<input id ="element180_9" value = "значение"><!-- поле ввода-->
<input id="button180_9" type="submit" value="Проверка"> <!-- кнопка -->

<h3>211_11 Отработка изученного материала </h3>
<p class="elems180_11"> Александр </p><!-- тег параграфа  -->
<p class="elems180_11"> Борис </p><!-- тег параграфа  -->
<p class="elems180_11"> Виктор </p><!-- тег параграфа  -->
<p class="elems180_11"> Григорий </p><!-- тег параграфа  -->
<input id="button180_11" type="submit" value=" Порядковый номер">

<h3>212 Работа с текстареа </h3>
<textarea id="elem181_1">text</textarea><!-- поле ввода раздела-->
<p id="elem181_2"> text </p><!-- тег параграфа  -->

<h3>213 Атрибут disabled блокировка элементов</h3>
<input id="elem182" disabled><!-- поле ввода-->
<input id ="elem182_1" type="submit" value="Проверка"><!-- кнопка -->

<h3>214  Работа с чекбоксами </h3>
<input type="checkbox" id="elem183_1"> <!-- поле чекбокса  -->
<!-- <input type="checkbox" checked id="elem"> -->
<input id="button183_1" type="submit" value="Проверка"><!-- кнопка -->
<input id="button183_2" type="submit" value="Проверка"><!-- кнопка -->

<h3>215  Чередование атрибутов без значений </h3>
<input id="elem184" disabled><!-- поле ввода-->
<input id="button184" type="submit"><!-- кнопка -->

<h3>216  Работа с радиокнопками </h3>
<input class="elem185" type="radio" name="elem185" value="1" checked><!-- радиокнопка-->
<input class="elem185" type="radio" name="elem185" value="2"><!-- радиокнопка-->
<input class="elem185" type="radio" name="elem185" value="3"><!-- радиокнопка-->
<input id="button185" type="submit"> <!-- кнопка -->

<h3>217 Событие change </h3>
<input id="elem186" value="text"><!-- поле ввода-->

<h3>218 Событие input </h3>
<input id="elem187" value="text"><!-- поле ввода-->

<h3>219 Методы focus и blur </h3>
<input id="elem188" value="text"/><!-- поле ввода-->
<input type="submit" id="button188_1"/><!-- кнопка -->

<h3>220 Работа с выпадающими списками </h3>
<select id="select189" multiple><!-- поле списка с выделением нескольких элементов с помощью  атрибута multiple-->
	<option value="1">one</option><!-- элемент списка -->
	<option value="2"selected>two</option><!-- элемент списка с выделением с помощью атрибута selected -->
	<option value="3">three</option><!-- элемент списка -->
</select>

<h3>221 Изменение выбранного пункта списка </h3>
<select id="select190"><!-- поле списка -->
	<option value="one">один</option><!-- элемент списка -->
	<option value="two" selected>два</option><!-- элемент списка с выделением с помощью атрибута selected -->
	<option value="three">три</option><!-- элемент списка -->
</select>
	<input type="submit" id="button190">
	
<h3>221_1 Изменение выбранного пункта списка </h3>

<select id="select190_1"><!-- поле списка -->
	<option value="1">январь</option><!-- элемент списка -->
	<option value="2">февраль</option><!-- элемент списка -->
	<option value="3">март</option><!-- элемент списка -->
	<option value="4">апрель</option><!-- элемент списка -->
	<option value="5">май</option><!-- элемент списка -->
	<option value="6">июнь</option><!-- элемент списка -->
	<option value="7">июль</option><!-- элемент списка -->
	<option value="8">август</option><!-- элемент списка -->
	<option value="9">сентябрь</option><!-- элемент списка -->
	<option value="10">октябрь</option><!-- элемент списка -->
	<option value="11">ноябрь</option><!-- элемент списка -->
	<option value="12">декабрь</option><!-- элемент списка -->
</select>

<h3>222 Номер выбранного пункта выпадающего списка </h3>
<select id="select191"><!-- поле списка -->
	<option value="1">январь</option><!-- элемент списка -->
	<option value="2">февраль</option><!-- элемент списка -->
	<option value="3">март</option><!-- элемент списка -->
	<option value="4">апрель</option><!-- элемент списка -->
	<option value="5">май</option><!-- элемент списка -->
	<option value="6">июнь</option><!-- элемент списка -->
	<option value="7">июль</option><!-- элемент списка -->
	<option value="8">август</option><!-- элемент списка -->
	<option value="9">сентябрь</option><!-- элемент списка -->
	<option value="10">октябрь</option><!-- элемент списка -->
	<option value="11"selected>ноябрь</option><!-- элемент списка -->
	<option value="12">декабрь</option><!-- элемент списка -->
</select>

<h3>223 Получение пунктов выпадающего списка </h3>
<select id="select192"><!-- поле списка -->
	<option value="1">январь</option><!-- элемент списка -->
	<option value="2">февраль</option><!-- элемент списка -->
	<option value="3">март</option><!-- элемент списка -->
	<option value="4">апрель</option><!-- элемент списка -->
	<option value="5">май</option><!-- элемент списка -->
	<option value="6">июнь</option><!-- элемент списка -->
	<option value="7">июль</option><!-- элемент списка -->
	<option value="8">август</option><!-- элемент списка -->
	<option value="9">сентябрь</option><!-- элемент списка -->
	<option value="10">октябрь</option><!-- элемент списка -->
	<option value="11"selected>ноябрь</option><!-- элемент списка -->
	<option value="12">декабрь</option><!-- элемент списка -->
</select>


<h3>224 Работа с пунктами выпадающего списка </h3>
<select id="select193"><!-- поле списка -->
	<option value="1">январь</option><!-- элемент списка -->
	<option value="2">февраль</option><!-- элемент списка -->
	<option value="3">март</option><!-- элемент списка -->
	<option value="4">апрель</option><!-- элемент списка -->
	<option value="5">май</option><!-- элемент списка -->
	<option value="6"selected>июнь</option><!-- элемент списка -->
	<option value="7">июль</option><!-- элемент списка -->
	<option value="8">август</option><!-- элемент списка -->
	<option value="9">сентябрь</option><!-- элемент списка -->
	<option value="10">октябрь</option><!-- элемент списка -->
	<option value="11">ноябрь</option><!-- элемент списка -->
	<option value="12">декабрь</option><!-- элемент списка -->
	</select>
	
<h3>225_11  Работа с ползунком </h3>
<input type="range" id="elem193_11" min="0" max="100" step="1" value="50"/> <!-- ползунок -->
<input  id="elem193_12" value="0"/> <!-- область ввода -->

<h3>226 Основы работы с объектом Event </h3>
<button id="elem194">text</button>

<h3>227 Координаты события </h3>
<div id="elem195">0 : 0</div> <!-- область блока -->

<h3>228 Тип события в объекте Event </h3>
<input type="submit" id="button196"/><!-- кнопка -->


<h3>229 Элемент события в объекте Event </h3>
<div id="elem197"><!-- тег области -->
	<p>text</p><!-- тег абзаца  -->
</div>

<h3>231 Отслеживание клавиш-модификаторов </h3>
<input type = "submit" id="elem199"/><!-- кнопка -->

<h3>232 Отмена действия по умолчанию </h3>

<a href="/" id="elem200">ссылка</a><!-- тег ссылки  -->


<h3>232_1 Практика  </h3>
<div id="elem200_5">
Выбор бабочки <select id="elem200_4"><!-- поле списка с выделением нескольких элементов с помощью  атрибута multiple-->
	<option value="33.gif"selected>красная бабочка</option><!-- элемент списка -->
	<option value="44.gif">фиалетовая бабочка</option><!-- элемент списка с выделением с помощью атрибута selected -->
	<option value="55.gif">голубая бабочка</option><!-- элемент списка -->
	<option value="66.gif">синяя бабочка</option><!-- элемент списка -->
</select><br/><br/>
Скорость <input type="range" id="elem200_3" min="0" max="100" step="1" value="6"/> <!-- ползунок -->
</div><hr/>
<div id="elem200_2">
<img id="elem200_1" src="33.gif" alt="Angry face" /><!-- картинка -->

</div>

<h3>233 Всплытие событий  </h3>
<div id="elem201_1">elem201_1<!-- область -->
<div id="elem201_2">elem201_2<!-- область -->
<div id="elem201_3">elem201_3<!-- область -->
</div>
</div>
</div>

<h3>234 Получение целевого элемента при всплытии событий</h3>
<div id="elem202">elem202<!-- область -->
<p id="elem202_1">elem202_1</p><!-- параграф -->
</div>

<h3>235 Прекращение всплытия событий</h3>
<div id="elem203_1">elem203_1<!-- область -->
<div id="elem203_2">elem203_2<!-- область -->
<div id="elem203_3">elem203_3<!-- область -->
</div>
</div>
</div>

<h3>236 Погружение событий</h3>
<div id="elem204_1">elem204_1<!-- область -->
<div id="elem204_2">elem204_2<!-- область -->
<div id="elem204_3">elem204_3<!-- область -->
</div>
</div>
</div>

<h3>237 Навешивание обработчиков на новые элементы в JavaScript</h3>
<ul id="elem205"><!-- список -->
	<li class="class205">item</li><!-- элемент списка -->
	<li class="class205">item</li><!-- элемент списка -->
	<li class="class205">item</li><!-- элемент списка -->
	<li class="class205">item</li><!-- элемент списка -->
	<li class="class205">item</li><!-- элемент списка -->
</ul>

<button id="button205_1">add</button><!-- кнопка -->

<h3>238 Делегирование событий</h3>
<ul id="elem206"><!-- список -->
	<li class="class206">item</li><!-- элемент списка -->
	<li class="class206">item</li><!-- элемент списка -->
	<li class="class206">item</li><!-- элемент списка -->
	<li class="class206">item</li><!-- элемент списка -->
	<li class="class206">item</li><!-- элемент списка -->
</ul>
<button id="button206_1">add</button><!-- кнопка -->

<h3>239 Основы работы с контекстом</h3>
<input id="elem207_1" value="text1"><!-- область ввода -->
<input id="elem207_2" value="text2"><!-- область ввода -->

<h3>241 Потеря контекста</h3>
<input id="elem209" value="text1"><!-- область ввода -->

<h3>242 Решение проблемы с контекстом</h3>
<input id="elem210" value="text1"><!-- область ввода -->
<input id="elem210_1" value="text1"><!-- область ввода -->

<h3>243 Привязывание контекста через метод call</h3>
<input id="elem211" value="23"><br/><!-- область ввода -->

<input id="elem211_1" value="text1"><!-- область ввода -->
<input id="elem211_2" value="text2"><!-- область ввода -->
<input id="elem211_3" value="text3"><!-- область ввода -->

<h3>245 Привязывание контекста через метод bind</h3>
<input id="elem213" value="text"><!-- область ввода -->

<h3>246 Основы работы с функцией setInterval</h3>
<input id="elem214" value="0"><!-- область ввода -->

<h3>247 248 249 Кнопка для запуска таймера на JavaScript</h3>
<input id="elem217" type="submit"value="Счетчик"><br/><!-- кнопка -->

<h3>250 Кнопки для запуска и остановки таймера</h3>
<input id="elem218_1" value="0"><br/><!-- область ввода -->
<input id="elem218_2" type="submit"value="Старт"><!-- кнопка -->
<input id="elem218_3" type="submit"value="Остановка"><!-- кнопка -->
<input id="elem218_4" type="submit"value="Очистить"><!-- кнопка -->

<h3>251 Практика на таймеры и работу с DOM</h3>
<input id="elem219" value="1"><br/><!-- область ввода -->

<h3>252 Таймеры и потеря контекста</h3>
<input id="elem220" value="text"><!-- область ввода -->

<h3>253 Передача контекста параметром функции setInterval</h3>
<input id="elem221" type="submit"value="кнопка"><!-- кнопка -->

<h3>254_2 Практика на таймеры и работу с DOM</h3>
<p id="elem222_22"> 10 </p><!-- тег параграфа  -->
<input id="elem222_2" type="submit"value="кнопка"><!-- кнопка -->

<h3>254_4 Практика на таймеры и работу с DOM</h3>
<p id="elem222_44"></p><!-- тег параграфа  -->
<input id="elem222_4" value="введите число"><!-- область ввода -->

<h3>254_6 Практика на таймеры и работу с DOM</h3>
<input id="elem222_61" value="0"><br/><!-- область ввода -->
<input id="elem222_62" type="submit"value="Старт"><!-- кнопка -->
<input id="elem222_63" type="submit"value="Остановка"><!-- кнопка -->

<h3>254_8 Практика на таймеры и работу с DOM</h3>
<p id="elem222_8"></p><!-- тег параграфа  -->

<h3>255 Метод setTimeout</h3>
<input type="submit" id="elem223"><!-- тег кнопки  -->

<h3>256 Создание и вставка элементов</h3>
<div id="parent224"><!-- тег области  -->
	<p>1</p><!-- тег параграфа  -->
	<p>2</p><!-- тег параграфа  -->
	<p>3</p><!-- тег параграфа  -->
</div>
<input type="submit" id="elem224_1">

<h3>257 Привязывание событий при вставке элементов</h3>
<div id="parent225"><!-- тег области  -->
	<p>1</p><!-- тег параграфа  -->
	<p>2</p><!-- тег параграфа  -->
	<p>3</p><!-- тег параграфа  -->
</div>

<h3>258 Создание элементов в цикле</h3>
<div id="parent226"></div><!-- тег области  -->

<h3>259 Навешивание обработчиков в цикле</h3>
<div id="parent227"></div><!-- тег области  -->

<h3>260 Создание элементов из массива</h3>
<div id="parent228"></div><!-- тег области  -->

<h3>261_1 Практика на создание списков ul</h3>
<ul id="parent229_1"></ul><!-- тег списка  -->

<h3>261_4 Практика на создание списков ul</h3>
<ul id="parent229_4"></ul><!-- тег списка  -->

<h3>262 Создание HTML таблиц</h3>
<table id="table230"></table><!-- тег таблицы  -->

<h3>263 Последовательное заполнение HTML таблиц</h3>
<table id="table231"></table><!-- тег таблицы  -->

<h3>264 Создание HTML таблицы из массива</h3>
<table id="table232"></table><!-- тег таблицы  -->

<h3>265 Создание HTML таблицы из массива объектов</h3>
<table id="table233"></table><!-- тег таблицы  -->

<h3>266 Добавление рядов и колонок в HTML таблицу</h3>
<table id="table234"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td>1</td><!-- тег столбца -->
		<td>2</td><!-- тег столбца -->
		<td>3</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>4</td><!-- тег столбца -->
		<td>5</td><!-- тег столбца -->
		<td>6</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>7</td><!-- тег столбца -->
		<td>8</td><!-- тег столбца -->
		<td>9</td><!-- тег столбца -->
	</tr>
</table>

<h3>267 Изменение ячеек HTML таблицы</h3>
<table id="table235"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td>1</td><!-- тег столбца -->
		<td>2</td><!-- тег столбца -->
		<td>3</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>4</td><!-- тег столбца -->
		<td>5</td><!-- тег столбца -->
		<td>6</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>7</td><!-- тег столбца -->
		<td>8</td><!-- тег столбца -->
		<td>9</td><!-- тег столбца -->
	</tr>
</table>

<h3>268 Порядковый номер ячейки таблицы</h3>
<table id="table236"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
	</tr>
</table>

<h3>269 Номер колонки и ряда таблицы</h3>
<table id="table237"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
		<td></td><!-- тег столбца -->
	</tr>
</table>

<h3>270 Порядковый номер ячейки по клику</h3>
<table id="table238"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
</table>

<h3>271 Порядковый номер клика в ячейке</h3>
<table id="table239"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
</table>

<h3>272 Удаление элементов</h3>
<div id="parent240"><!-- тег области -->
	<p id="elem240_1">elem 1</p><!-- тег параграфа -->
	<p id="elem240_2">elem 2</p><!-- тег параграфа -->
	<p id="elem240_3">elem 3</p><!-- тег параграфа -->
</div>
<input type="submit" id="elem240"  value="удалить теги">


<h3>273 Самоудаление элементов</h3>
<div id="parent241">
	<p>elem 1</p><!-- тег параграфа -->
	<p>elem 2</p><!-- тег параграфа -->
	<p>elem 3</p><!-- тег параграфа -->
	<p>elem 4</p><!-- тег параграфа -->
	<p>elem 5</p>
</div>

<h3>274 Самоудаление новых элементов</h3>
<div id="parent242"></div><!-- тег области -->
<input type="submit" id="elem242"  value="удалить теги"><!-- тег кнопки -->


<h3>275 Ссылка на удаление элемента</h3>
<div id="parent243"><!-- тег области -->
	<p id="elem243">text</p><!-- тег параграфа -->
	<a href="" id="remove243">remove</a><!-- тег ссылки-->
</div>

<h3>276 Создание ссылок для удаление элементов</h3>
<div id="parent244"><!-- тег области -->
	<p>text1</p><!-- тег параграфа -->
	<p>text2</p><!-- тег параграфа -->
	<p>text3</p><!-- тег параграфа -->
</div>


<h3>277 Создание ссылок для удаление элементов - Методы append, prepend и insertBefore</h3>
<div id="parent245"><!-- тег области -->
	<p>----1----</p><!-- тег параграфа -->
	<p id="before245">----2----</p><!-- тег параграфа -->
</div>

<h3>278 Смежная вставка элементов. Методы insertAdjacentElement и insertAdjacentHTML</h3>
<div id="target246"><!-- тег области -->
	<p>elem</p><!-- тег параграфа -->
</div>

<h3>279 Клонирование элементов</h3>
<div id="parent247">
	<div class="elem247"><!-- тег параграфа -->
		<p>первый абзац</p><!-- тег параграфа -->
		<p>второй абзац</p><!-- тег параграфа -->
	</div>
</div>

<h3>280 Проверка элементов</h3>

<p id="elem248" class="www248"></p><!-- тег параграфа -->

<div id="parent248_2"><!-- тег области -->
	<p id="child248_2"></p><!-- тег параграфа -->
</div>

<h3>281 Редактирование отдельного элемента</h3>
<div id="parent249"><!-- тег области -->
	<p id="elem249">text</p><!-- тег параграфа -->
	<input id="input249"><!-- тег области ввода -->
</div>

<h3>282 Прячем текст при редактировании элемента</h3>
<div id="parent250"><!-- тег области -->
	<p id="elem250">text</p><!-- тег параграфа -->
</div>

<h3>283 Редактирование в группе элементов</h3>
<div id="parent251"><!-- тег области -->
<p>text1</p><!-- тег параграфа -->
<p>text2</p><!-- тег параграфа -->
<p>text3</p><!-- тег параграфа -->
</div>

<h3>284 Одновременное редактирование и удаление элементов</h3>
<div id="parent252"><!-- тег области -->
	<p><span>text1</span><a href="">reme</a></p><!-- тег параграфа -->
	<p><span>text2</span><a href="">remve</a></p><!-- тег параграфа -->
	<p><span>text3</span><a href="">remo</a></p><!-- тег параграфа -->
	<p><span>text1</span><a href="">link</a></p><!-- тег параграфа -->
<p><span>text2</span><a href="">link</a></p><!-- тег параграфа -->
<p><span>text3</span><a href="">link</a></p><!-- тег параграфа -->
</div>


<h3>285 Стилизация элементов</h3>
<div id="parent253"><!-- тег области -->
<p><span>text1</span></p><!-- тег параграфа -->
<p><span>text2</span></p><!-- тег параграфа -->
<p><span>text3</span></p><!-- тег параграфа -->
</div>

<h3>286 Кнопки для скрытия и показа элемента</h3>
<p id="elem254">text</p><!-- тег параграфа -->
<input type="submit" id="show254" value="show"><!-- тег кнопки -->
<input type="submit" id="hide254" value="hide"><!-- тег кнопки -->

<h3>287_1 Много элементов с кнопками показа</h3>
<div id="parent255_1"><!-- тег области -->
<p id="elem255_11">1</p><button data-elem="elem255_11">toggle</button>
<p id="elem255_12">2</p><button data-elem="elem255_12">toggle</button>
<p id="elem255_13">3</p><button data-elem="elem255_13">toggle</button>
</div>

<h3>287_2 Много элементов с кнопками показа</h3>
<div id="parent255_2"><!-- тег области -->
<p id="elem255_21">1</p><button >toggle</button>
<p id="elem255_22">2</p><button >toggle</button>
<p id="elem255_23">3</p><button >toggle</button>
</div>

<h3>287_3 Много элементов с кнопками показа</h3>
<div id="parent255_3"><!-- тег области -->
<p id="elem255_31">1</p><button >toggle</button>
<p id="elem255_32">2</p><button >toggle</button>
<p id="elem255_33">3</p><button >toggle</button>
</div>

<h3>288 Активация элементов</h3>
<table id="table256"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
</table>


<h3>289 Чередование стилей активации</h3>
<table id="table257"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
</table>

<h3>289_1 Чередование стилей активации</h3>
<table id="table257_1"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
</table>

<h3>290 Активация ограниченного количества элементов</h3>
<table id="table258"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
</table>

<h3>291_1 Практика на изменение элементов</h3>
<ul id="elem259_1"><!-- список -->
	<li>item</li><!-- элемент списка -->
	<li>item</li><!-- элемент списка -->
	<li>item</li><!-- элемент списка -->
	<li>item</li><!-- элемент списка -->
	<li>item</li><!-- элемент списка -->
</ul>
<input type="submit" id="show259_3" value="show"><!-- тег кнопки -->
<input type="submit" id="hide259_3" value="hide"><!-- тег кнопки -->
<input type="submit" id="create259_3" value="create"><!-- тег кнопки -->

<h3>292 Поиск ячеек таблицы с помощью атрибута data</h3>
<table id="table260"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td data-col="1"></td><!-- тег столбца -->
		<td data-col="2"></td><!-- тег столбца -->
		<td data-col="3"></td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td data-col="1"></td><!-- тег столбца -->
		<td data-col="2"></td><!-- тег столбца -->
		<td data-col="3"></td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td data-col="1"></td><!-- тег столбца -->
		<td data-col="2"></td><!-- тег столбца -->
		<td data-col="3"></td><!-- тег столбца -->
	</tr>
</table>

<h3>293 Добавление номера колонки и ряда в таблицу</h3>
<table id="table261"><!-- тег таблицы  -->
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
	<tr><!-- тег строки -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
		<td>0</td><!-- тег столбца -->
	</tr>
</table>

<h3>294 Поиск ячеек таблицы через селектор CSS</h3>
<table id="table262"><!-- тег таблицы  -->
	<tr class="line262"><!-- тег строки -->
		<td class="child262">11</td><!-- тег столбца -->
		<td class="child262">12</td><!-- тег столбца -->
		<td class="child262">13</td><!-- тег столбца -->
	</tr>
	<tr class="line262"><!-- тег строки -->
		<td class="child262">1</td><!-- тег столбца -->
		<td class="child262">2</td><!-- тег столбца -->
		<td class="child262">3</td><!-- тег столбца -->
	</tr>
	<tr class="line262"><!-- тег строки -->
		<td class="child262">31</td><!-- тег столбца -->
		<td class="child262">32</td><!-- тег столбца -->
		<td class="child262">33</td><!-- тег столбца -->
	</tr>
</table>

<h3>295 Функции для работы с DOM элементом</h3>
<p id="elem263_1">1</p><!-- тег параграфа -->
<p id="elem263_2">1</p><!-- тег параграфа -->

<h3>296 Функции для работы с группой DOM элементов</h3>
<p class="elem264"></p><!-- тег параграфа -->
<p class="elem264"></p><!-- тег параграфа -->
<p class="elem264"></p><!-- тег параграфа -->

<h3>297 Передача коллбэка для работы с DOM</h3>
<p class="elem297">1</p><!-- тег параграфа -->
<p class="elem297">2</p><!-- тег параграфа -->
<p class="elem297">3</p><!-- тег параграфа -->
<p class="elem297">4</p><!-- тег параграфа -->
<p class="elem297">5</p><!-- тег параграфа -->

<h3>298 Передача порядкового номера в коллбэк</h3>
<p class="elem298">1</p><!-- тег параграфа -->
<p class="elem298">2</p><!-- тег параграфа -->
<p class="elem298">3</p><!-- тег параграфа -->
<p class="elem298">4</p><!-- тег параграфа -->
<p class="elem298">5</p><!-- тег параграфа -->

<h3>299 Передача DOM элемента параметром функции</h3>
<p id="elem299_1"></p><!-- тег параграфа -->
<p id="elem299_2"></p><!-- тег параграфа -->

<h3>300 Передача DOM группы элементов параметрами функций</h3>
<p class="elem300"></p><!-- тег параграфа -->
<p class="elem300"></p><!-- тег параграфа -->
<p class="elem300"></p><!-- тег параграфа -->
<p class="elem300"></p><!-- тег параграфа -->
<p class="elem300"></p><!-- тег параграфа -->

<h3>301 Передача DOM группы элементов параметрами функций</h3>
<div id="elem301"><!-- тег области -->
</div>

<h3>302 Возврат таблицы из функции</h3>
<div id="elem302"><!-- тег области -->
</div>

<h3>303 Функция для создания таблицы из двухмерного массива</h3>
<div id="elem303"><!-- тег области -->
</div>

<h3>304 Создание HTML таблицы из одномерного массива</h3>
<div id="elem304"><!-- тег области -->
</div>

<h3>305 Нехватка элементов в массиве при создании таблицы</h3>
<div id="elem305"><!-- тег области -->
</div>

<h3>306 Конфликты переменных</h3>

<h3>307 Модули через замыкания</h3>
<div id="div307_1">10</div><!-- тег области -->
<div id="div307_2">10</div><!-- тег области -->

<h3>308 Передача параметров в модуль через замыкания</h3>
<div id="div308">3</div><!-- тег области -->
<button id="btn308">click me</button><!-- тег кнопки -->

<h3>309 Передача родительского элемента в модуль через замыкания</h3>
<div id="div309_1">1</div><!-- тег области -->
<div id="div309_2">2</div><!-- тег области -->
<div id="div309_3">3</div><!-- тег области -->
<div id="res309"></div><!-- тег области -->
<button id="btn309">click me</button><!-- тег кнопки -->

<div id="parent3092">
	<div id="div3092_1">1</div><!-- тег области -->
	<div id="div3092_2">2</div><!-- тег области -->
	<div id="div3092_3">3</div><!-- тег области -->
	<div id="res3092"></div><!-- тег области -->
	
	<button id="btn3092">click me</button><!-- тег кнопки -->
</div>

<h3>310 Передача настроек модуля через замыкания </h3>
<div id="parent310_1"></div><!-- тег области -->
****************************
<div id="parent310_2"></div><!-- тег области -->
****************************
<div id="parent310_3"></div><!-- тег области -->

<h3>311 Экспорт переменных и функций в модулях через замыкания </h3>

<h3>312 Библиотеки через замыкания </h3>

<script>
	//ваш JavaScript код
//_________________________________________________			
// 	181 Получение DOM элементов

let button = document.querySelector('#button');//объявляем переменную batton,
// которой присваиваем результат исполнения команды querySelector в документе
console.log(button);//выводим результат переменной batton
		
let elem = document.querySelector('#parent input');//объявляем переменную elem,
// которой присваиваем результат исполнения команды querySelector в документе
console.log(elem);//выводим результат переменной elem

let R = document.querySelector('.elem');//объявляем переменную R,
// которой присваиваем результат исполнения команды querySelector в документе
console.log(button);//выводим результат переменной batton
console.log(R); // //выводим результат переменной R

//_________________________________________________
// 	182 Привязывание обработчиков событий к элементам

let button1 = document.querySelector('#button1');//объявляем переменную batton1,
// которой присваиваем результат исполнения команды querySelector в документе
button1.addEventListener('click', function() {alert('!!!');});// К переменной batton1 применяем метод - 
//обработчик событий addEventListener где 1 параметр - событие, а 2 - функция колбэк

//_________________________________________________		
// 183 	Другие типы событий
//с помощью события dblclick можно отловить двойной клик по элементу,
// с помощью события mouseover - наведение курсора на элемент, 
//а с помощью события mouseout - уход курсора с элемента.
let button2 = document.querySelector('#button2');
let button3 = document.querySelector('#button3');
let button4 = document.querySelector('#button4');
button2.addEventListener('mouseover', function(){alert('!!!');})
button3.addEventListener('mouseout', function(){alert('!!!');})
button4.addEventListener('dblclick', function(){alert('!!!');})

//_________________________________________________		
//184 Именованные обработчики событий
// функция может быть и обычной, с именем. 
let button5 = document.querySelector('#button5');
button5.addEventListener('click', func);

function func() {
	alert('!!!');
}

//_________________________________________________		
//185 Привязывание одного обработчика ко многим элементам
//Одну функцию можно привязать сразу к нескольким элементам. 
//Пусть для примера у нас есть следующая функция:

function func() {//функция вывода на экран
	alert('!!!');
}

let button6 = document.querySelector('#button6'); //создаем переменные для кнопок 6
let button7 = document.querySelector('#button7');//создаем переменные для кнопок 7
button6.addEventListener('click', func);//применяем к кнопкам метод событий addEventListener 
//-на клик исполняет функцию
button7.addEventListener('click', func);//применяем к кнопкам метод событий addEventListener 
//-на клик исполняет функцию

function funcs() {//функция вывода на экран
	alert('message');
}

let elem1 = document.querySelector('#elem1');//создаем переменные для тегоф параграффа
let elem2 = document.querySelector('#elem2');//создаем переменные для тегоф параграффа
let elem3 = document.querySelector('#elem3');//создаем переменные для тегоф параграффа
let elem4 = document.querySelector('#elem4');//создаем переменные для тегоф параграффа
let elem5 = document.querySelector('#elem5');//создаем переменные для тегоф параграффа
elem1.addEventListener('click', funcs);//применяем к кнопкам метод событий addEventListener
elem2.addEventListener('click', funcs);//применяем к кнопкам метод событий addEventListener
elem3.addEventListener('click', funcs);//применяем к кнопкам метод событий addEventListener
elem4.addEventListener('click', funcs);//применяем к кнопкам метод событий addEventListener
elem5.addEventListener('click', funcs);//применяем к кнопкам метод событий addEventListener

//_________________________________________________	
//186 Несколько обработчиков одного события
function func1() {//объявляем первую функцию
	alert('1');
}

function func2() {//объявляем вторую функцию
	alert('2');
	}
	let button8 = document.querySelector('#button8');//передаем тег кнопка8 в переменную 
	button8.addEventListener('click', func1);//применяем метод к кнопке8 спри наведении исполняет функцию
button8.addEventListener('click', func2);//применяем метод к кнопке8 спри наведении исполняет функцию


//_________________________________________________	
//187 Работа с текстом тега
let button9 = document.querySelector('#button9');//содаем переменную и присваевыем ее к тегу кнопки9 под id #button9
let elem6   = document.querySelector('#elem6');//содаем переменную и присваевыем ее к тегу абзаца6 под id #elem6
button9.addEventListener('click', function() {//к переменной кнопки9 применяем метод событий addEventListener - при клике
//исполняем функцию, вызываем переменную elem6  применяем к ней свойство innerHTML позволяющее прочитывать  текст тегов
elem6.innerHTML = '!!!';//применяем к ней свойство innerHTML позволяющее прочитывать  текст тегов или изменить как сейчас
alert(elem6.innerHTML);//выводим на экран
});
	
let button10 = document.querySelector('#button10');//содаем переменную и присваевыем ее к тегу кнопки9 под id #button10
let elem7 = document.querySelector('#elem7');////содаем переменную и присваевыем ее к тегу абзаца6 под id #elem7
button10.addEventListener('dblclick', function()//к переменной кнопки9 применяем метод событий addEventListener-при двойном клике
{
elem7.innerHTML = '<b>жирный текст</b>';//применяем к ней свойство innerHTML позволяющее прочитывать  текст тегов или изменить 
//как сейчас <b>жирный текст</b>
alert(elem7.innerHTML);//выводим на экран
})

//_________________________________________________	
//188 Работа с атрибутами тегов через свойства элементов
let button159 = document.querySelector('#button159');//присваиваем в переменную кнопку button159
let elem159   = document.querySelector('#elem159');//присваиваем в переменную поле ввода elem159
button159.addEventListener('click', function() { //применяем  метод событий -addEventListener к переменной button159
	alert(elem159.id);   // выведет 'elem159'
	alert(elem159.type); // выведет 'text'
	alert(elem159.value); // выведет '12345'(то что вводили в поле)
	
	elem159.type = 'submit'; // присвоим новое значение атрибуту type
});

let button159_1_2 = document.querySelector('#button159_1_2');//присваиваем в переменную кнопку button159_1_2
let elem159_1 = document.querySelector('#elem159_1');//присваиваем в переменную поле ввода elem159_1
let elem159_2 = document.querySelector('#elem159_2');//присваиваем в переменную поле ввода elem159_2
let elem159_3 = document.querySelector('#elem159_3');//присваиваем в переменную поле ввода elem159_3
button159_1_2.addEventListener('click', function() {//применяем  метод событий -addEventListener к переменной button159_1_2
let result = (Number (elem159_1.value) + Number (elem159_2.value))//достаем значения забитых полей ввода с помощью свойства 
//value и делаем их числовыми
alert(result);//выводим на экран
elem159_3.value = result//присваиваем в value поля ввода значение из переменной result
})

// 1_2задачи
let elem159_4 = document.querySelector('#elem159_4');//присваиваем в переменную поле ввода elem159_4
let button159_1 = document.querySelector('#button159_1');//присваиваем в переменную кнопку button159_1
button159_1.addEventListener('click', function()//применяем к переменной button159_1  метод событий -addEventListener
{
alert(elem159_4.type); // выведет 'email' //выводим тип поля elem159_4
elem159_4.type = 'submit';//меняем тип поля elem159_4 на кнопку 
})
// 3задача
let elem159_5 = document.querySelector('#elem159_5');//присваиваем в переменную поле параграфа elem159_5
let button159_2 = document.querySelector('#button159_2');//присваиваем в переменную кнопку button159_2
button159_2.addEventListener ('dblclick', function() //применяем к переменной button159_2  метод событий -addEventListener
{
elem159_5.innerHTML = elem159_5.innerHTML + ' -http://ruseller.com' //с помощью свойства innerHTML позволяющее прочитывать текст тегов 
})//записываем новое значение тега elem159_5
// 5 6 7задачи
let elem159_6 = document.querySelector('#elem159_6');//создаем переменную от картинки 
let button159_3 = document.querySelector('#button159_3');//присваиваем в переменную кнопку button159_3
let button159_4 = document.querySelector('#button159_4');//присваиваем в переменную кнопку button159_4
let heightdecrease = 50//переменная со значением 50 
let widthdecrease = 50//переменная со значением 50 
let heightincrease = 50//переменная со значением 50 
let widthincrease = 50//переменная со значением 50 
button159_3.addEventListener ('click', function()//применяем  метод событий -addEventListener к переменной button159_3
{
elem159_6.height = elem159_6.height - heightdecrease//обращаемся к атрибуту высоты тега рисунка  
elem159_6.width = elem159_6.width - widthdecrease//обращаемся к атрибуту ширины тега рисунка  
})
button159_4.addEventListener ('click', function()//применяем  метод событий -addEventListener к переменной button159_4
{
elem159_6.height = elem159_6.height + heightincrease//обращаемся к атрибуту высоты тега рисунка 
elem159_6.width = elem159_6.width + widthincrease//обращаемся к атрибуту ширины тега рисунка  
})

//_________________________________________________	
//189 Работа с текстовыми полями
let button160_1 =document.querySelector ('#button160_1'); //переменная  от тега кнопки
let elem160_1 =document.querySelector ('#elem160_1');//переменная  от тега области ввода
button160_1.addEventListener ('click', function(){//метод событий применяемый к переменной кнопки
alert (elem160_1.value);//вывод на экран содержимого области ввода с помощью свойства атрибута value
elem160_1.value = 'new text'; //новое значение elem160_1 c помощью. value
})

//_________________________________________________	
//190 Фокус текстовых полей
let elem161_1 = document.querySelector('#elem161_1'); // присваиваем переменной значение поля ввода по id 
elem161_1.addEventListener('focus', function() { //вызываем событийный метод к переменной с событием focus
	console.log(elem161_1.value);//значение поля выводим в консоль
});

//_________________________________________________	
//191 Исключения при работе с атрибутами
//При работе с атрибутами существует исключение - это атрибут class. Это слово является специальным в JavaScript 
//и поэтому мы не можем просто написать elem.class, чтобы считать значение атрибута class. Вместо этого следует писать elem.className.
let elem162_1 = document.querySelector('#elem162_1');//создаем переменную поля
let button162_1 =document.querySelector ('#button162_1');//создаем переменную кнопки
button162_1.addEventListener ('click', function()//метод событий применяем к кнопке - выполняем фукцию при клике
{
alert(elem162_1.className); // выведет 'aaa bbb'
})

//_________________________________________________	
//192 Цепочки методов и свойств
//let elem163_1 = document.querySelector('#elem163_1');
//alert(elem163_1.value); // выведет 'text'
//мы сначала получаем элемент по его id, записываем этот элемент в переменную elem, 
//а затем выводим на экран свойство value из этой переменной.
//можно не вводить переменную elem, а строить цепочку из точек таким образом:
document.querySelector('#button163_1').addEventListener ('click', function()
{
document.querySelector('#elem163_1').value = 'www';
alert( document.querySelector('#elem163_1').value ); // выведет 'www'
})

//_________________________________________________	
//193 Объект this
//специальный объект this, доступный в функции-обработчик события, этот объект указывает на элемент, в котором произошло событие.
//Объект this удобен, когда элемент, в котором произошло событие, и элемент, с которым совершаются действия в результате события, 
//- это один и тот же элемент.


//let button164_1 = document.querySelector('#button164_1');
//let button164_2 = document.querySelector('#button164_2');
//let button164_3 = document.querySelector('#button164_3');

//button164_1.addEventListener('click', func);
//button164_2.addEventListener('click', func);
//button164_3.addEventListener('click', func);
//function func() {
	//console.log(this.value);
//}


let button164_1 = document.querySelector('#button164_1');
let button164_2 = document.querySelector('#button164_2');
let button164_3 = document.querySelector('#button164_3');


button164_1.addEventListener('click', function func(){
	console.log(button164_1.value);
});
button164_2.addEventListener('click', function func(){
	console.log(button164_2.value);
});
button164_3.addEventListener('click', function func(){
	console.log(button164_3.value);
});
//_________________________________________________	
//194 Получение группы элементов
// Для получения группы элементов и проделывать какие-нибудь операции сразу со многими элементами используют етод querySelectorAll, 
//получающий все теги, подпадающие под CSS селектор, в виде массива элементов. Чтобы сделать что-нибудь с найденными элементами, 
//нужно поработать с полученным массивом, например, перебрать его циклом и в цикле выполнить какую-либо операцию с каждым элементом
// по отдельности.
let elems = document.querySelectorAll('.www165');//метод querySelectorAll примененный к классу парагрофов передается переменной
for (let elem of elems) {//создаем цикл
	elem.innerHTML = elem.innerHTML + '!'; //метод innerHTML применен к переменной elem и к ней добавляем "!"
	console.log(elem.innerHTML);//выводим элементов массива на экран
	}
	
//_________________________________________________	
//195 Добавление обработчиков событий в цикле
let elements166 = document.querySelectorAll ('.www166');//получаем группу элементов из класса тегов, запишется в массив
for (let elem of elements166) {//цикл перебираем массив
	elem.addEventListener('click', func166);//применяем метод событий с функцией 
}
function func166() {//функция исполняет каждый элемент отдельно
	alert('!');//вывод
		alert(this.innerHTML)//выводим элементов массива на экран
}

//_________________________________________________	
//196 Отвязывание событий через removeEventListener
// отвязывать обработчики события, которые ранее были привязаны нами к элементам

let button167 = document.querySelector('#button167');
button167.addEventListener('click', func167);//метод событий, добавление клика и функции к переменной button167

function func167() {//объявляем функцию
	alert('!!!');//выводим на экран
		this.removeEventListener('click', func167);//метод запрещает событие клика и выполнение функции
}

//_________________________________________________	
//197 Отвязывание обработчиков событий в цикле
let elems168 = document.querySelectorAll('.colored168');//присваивае переменной теги параграфов
for (let elem168 of elems168) {//перебираем их в цикле
	elem168.addEventListener('click', func168);//применяем событийный метод
}
function func168() {//объявляем функцию 
	this.removeEventListener('click', func168); // отвязываем обработчик
	alert(this.innerHTML);//выводим на экран
}

//_________________________________________________	
//198 Отвязывание анонимных функций
let elems169 = document.querySelectorAll('.colored169');//присваивае переменной теги параграфов
for (let elem169 of elems169) {//перебираем их в цикле
	elem169.addEventListener('click', function func169() {//применяем событийный метод
		alert(this.innerHTML);
		this.removeEventListener('click', func169); // отвязываем функцию
	});
}

//_________________________________________________	
//199 Работа с атрибутами через методы

//Метод getAttribute
/*
let elem170 = document.querySelector ('#elem170')//создаем переменную поля ввода
let button170 = document.querySelector ('#button170')//создаем переменную кнопки
button170.addEventListener ('click', function func170(){//применяем к переменной кнопки метод событий 
elem170.value = 'querySelector!!!'//задаем новое содержиое тега
elem170.className = 'stile170'//задаем новый класс
let value = elem170.getAttribute('value');//Метод getAttribute считывает значение заданного атрибута у тега.
console.log(value);//выведет  'querySelector!!!'
console.log (elem170.value)//выведет 'abcde'
elem170.setAttribute('value', '!!!');// Метод setAttribute добавляет новый атрибут или позволяет изменить значение сущестующего 
//атрибута какого-либо тега.
console.log (elem170.value)//выведет !!!
elem170.removeAttribute('value');//Метод removeAttribute удаляет заданный атрибут у какого-либо тега. Выведет "null"
console.log(elem170.hasAttribute('value'));//Метод hasAttribute проверяет наличие заданного атрибута у элемента.
//Если атрибут есть - выведет true, если нет - выведет false.//выведет-false
})
button170.addEventListener ('blur', function func170_1(){//к переменной кнопки применяем метод событий
elem170.className = 'stile170_1'//к полю ввода применяем новый стиль
elem170.value ='**********'//изменяем параметры ввода
})*/

//______________________________
//200 Разница между способами получения атрибутов
let elem171 = document.querySelector('#elem171');// объявляем переменную elem 171
let button171 = document.querySelector ('#button171')//объявляем переменную button171
button171.addEventListener ('click', function func171(){//применяем метод событий 
elem171.className = 'stile171';//изменяем класс присвоив значение 'stile171'
elem171.value = 'new2022year'; // присвоим новое свойство содержимого поля ввода
console.log(elem171.value)// выведет "new 2022 year"
elem171.setAttribute('value', 'new2022year');//изменяем свойство содержимого поля ввода
let value171 = elem171.getAttribute('value');//вызовем атрибут содержимого поля ввода и запишем в переменную
console.log (value171)//выведем в консоль "new 2022 year"
})

//______________________________
//201 Манипулирование CSS классами в JavaScript

//Свойство classList
let elem172 = document.querySelector('#elem172');//присваиваем переменной значение тега параграфа
let length172 = elem172.classList.length;//присваиваем переменной значение длинны псевдомассива, 
//полученному от свойства classList
console.log(length172);//выводим значение переменной - кол-во подключенных классов
//Перебираем классы
let classNames172 = elem172.classList;//записываем коллекцию классов в массив
let b = [];//создаем пустой массив результатов
for (let className172 of classNames172) {//перебираем массив
	console.log(className172 );//выводим поочередер каждое название стиля на экран
	if (className172 != 'zzz')//условие если стиль не равен zzz
	{
	b.push(className172);//записать в новый массив b
	}
}
console.log (b);//выводим в кансоль массив b
elem172.className = b;//присваиваем к атрибуту className  значения массива b

//Метод add объекта classList, cинтаксис - элемент.classList.add(класс);
let elem172_1 = document.querySelector('#elem172_1'); //присваиваем переменной значения поля параграфа
elem172_1.classList.add('kkk');//метод add добавляет в массив свойства classList новый элемент (стиль)
//Метод remove объекта classList удаляет заданный CSS класс элемента, cинтаксис - элемент.classList.remove(класс);
let elem172_2 = document.querySelector('#elem172_2'); //присваиваем переменной значения поля параграфа
elem172_2.classList.remove('zzz');//метод remove удаляет в массиве свойства classList  (стиль)
let length172_2 = elem172_2.classList.length;//кол-во стилей передаем переменной
console.log(length172_2)//вызываем кол-во стилей
//Метод contains объекта classList проверяет наличие CSS класса элемента.Синтаксис -элемент.classList.contains(класс);
let elem172_3 = document.querySelector('#elem172_3');//присваиваем переменной значения поля параграфа
let contains172_3 = elem172_3.classList.contains('ggg');//метод contains проверяет  массив есть ли свойства из параметра (стиль)
console.log(contains172_3);//вызываем кол-во стилей
//Метод toggle объекта classList чередует заданный CSS класс элемента: добавляет класс, если его нет и удаляет, если есть.
//синтаксис элемент.classList.toggle(класс);
let elem172_4 = document.querySelector('#elem172_4');//присваиваем переменной значения поля параграфа
elem172_4.classList.toggle('zzz');//удалил класс zzz c помощью Метод toggle -Если элемент изначально отображается, 
//то он будет скрыт, если элемент скрыт, то он будет отображен.

//______________________________
//202 Стилизация элементов через атрибут style
//научимся добавлять CSS стили элементам. Это делается путем изменения атрибута style. К примеру, чтобы поменять цвет, 
//нужно построить следующую цепочку: elem.style.color, и присвоить ей нужное значение цвета.
let elem173 = document.querySelector('#elem173');//присваиваем переменной значения поля параграфа
elem173.style.color = '#DD5145';//добавляем стиль цвета
//Свойства, которые записываются через дефис, например font-size, преобразуются в camelCase.
// То есть font-size станет fontSize:
elem173.style.fontSize = '20px';//добавляем стиль размера шрифта
//Свойство float является исключением, так как оно является специальным в JavaScript. 
//Для него следует писать cssFloat:
elem173.style.cssFloat = 'right';//добавляем стиль позиционирования

//______________________________
//203 Стилизация с помощью CSS классов
let elems174 = document.querySelectorAll('.colored');// добавяем переменную по классу
for (let elem174 of elems174) {//перебираем массив
	elem174.addEventListener('click', function color174() {//добавляем новый класс
		this.classList.toggle('colored174'); // изменение абзаца класс или запись с помощью add
	});
}
//Применение
let button174_1 = document.querySelector('#button174_1');
let elem174_1 = document.querySelector('#elem174_1');

button174_1.addEventListener('click', function() {
	elem174_1.classList.toggle('active');
});

//______________________________
//204 Нахождение элементов по родственным связям

//Свойство firstElementChild содержит первый дочерний элемент. 
//Дочерними элементами считаются все теги, которые непосредственно расположены внутри блока.
//Если у элемента нет дочерних элементов - возвращается null. Синтаксис элемент.firstElementChild
let parent175_1 = document.querySelector('#parent175_1');//объявляем переменную куда передаем значение области
let text175_1 = parent175_1.firstElementChild.innerHTML;//применяем свойство firstElementChild,вызывает первый дочерний элемент.
console.log(text175_1);//выведет '1'

//Свойство lastElementChild хранит в себе последний дочерний элемент. Дочерними элементами считаются все теги,
// которые непосредственно расположены внутри блока. Если у элемента нет дочерних элементов - возвращается null.
let parent175_2 = document.querySelector('#parent175_2');//объявляем переменную куда передаем значение области
let text175_2 = parent175_2.lastElementChild.innerHTML;//применяем свойство lastElementChild, который вызывает последний дочерний 
//элемент.
console.log(text175_2);//выведет '3'

//Свойство children хранит в себе псевдомассив дочерних элементов. Дочерними элементами считаются все теги,
// непосредственно расположеные внутри блока.
let parent175_3 = document.querySelector('#parent175_3');//объявляем переменную куда передаем значение области
let elems175_3 = parent175_3.children; //применяем к области свойство children (псевдомассив вложенных тегов)
for (let elem175_3 of elems175_3) {//циклом перебираем элементы
console.log(elem175_3.innerHTML);//выводим на экран консоли
}

//Свойство parentElement содержит родительский элемент.
let elem175_4 = document.querySelector('#elem175_4'); //объявляем переменную куда передаем значение области
let id = elem175_4.parentElement.id; //присваиваем переменной значение id результат исполнения elem175_4 со своиством 
//parentElement - вызываем родителя
console.log(id);//выводим на экран консоли, выведет 'parent'

//Метод closest ищет ближайший родительский элемент, подходящий под указанный CSS селектор, при этом сам элемент тоже
// включается в поиск. Синтаксис элемент.closest('селектор')
let elem175_5 = document.querySelector('#child175_5_1');//создаем переменную присвоив значение параграфа
let parent175 = elem175_5.closest('.www175_5');//применяем метод closest к элементу  elem175_5 с параметром где значение параметра 
//- класс .www
console.log(parent175.id);//применяем к значению parent класс id и выводим на экран

//Свойство previousElementSibling содержит предыдущий элемент, находящийся в этом же родителе. Если такого элемента нет 
//- возвращается null.
let elem175_6 = document.querySelector('#elem175_6');//создаем переменную присвоив значение параграфа
let text175_6 = elem175_6.previousElementSibling.innerHTML;//применяем свойство previousElementSibling (предыдущий тег такогоже типа) 
//и применяем свойство вывода содержимого innerHTML. Если соседа сверху нет или он расположен не в родителе нашего элемента,
//также возвращается null
console.log(text175_6);//выводит - "175_6 cвойство previousElementSibling"

//Свойство nextElementSibling содержит следующий элемент, находящийся в этом же родителе. Если такого элемента нет - 
//возвращается null.
let elem175_7 = document.querySelector('#elem175_7');//создаем переменную присвоив значение параграфа
let text175_7 = elem175_7.nextElementSibling.innerHTML;//применяем свойство nextElementSibling (вызыввет следующий тег 
//такогоже типа) и применяем свойство вывода содержимого innerHTML.
console.log(text175_7);// выводит 175_7 cвойство nextElementSibling

//______________________________
//205 другие полезные методы для поиска элементов

//Метод getElementById позволяет получить элемент страницы по его атрибуту id. С полученным элементом можно будет производить различные манипуляции: 
//менять его текст, атрибуты, CSS стили и так далее. Синтаксис -document.getElementById(ай ди элемента)
let elem176_1 = document.getElementById('elem176_1');//метод аналагичен document.querySelector (поиск ведется по id)
elem176_1.value = 'метод getElementById';// записываем в value (вывод содержания тега) - "метод getElementById"

//Метод getElementsByTagName позволяет получить элементы страницы по имени тега. С полученными элементами можно производить различные манипуляции: 
//менять их текст, атрибуты, CSS стили и так далее. Синтаксис document.getElementsByTagName(имя тега);
//let elems176_2 = document.getElementsByTagName('p');//выбираем все теги параграфа
//for (let elem176_2 of elems176_2) {//перебираем элементы параграфа
//elem176_2.innerHTML = '!!!';//записывем в область параграфа новое значение
//}

//Метод getElementsByClassName позволяет получить элементы страницы по их классу, заданному в атрибуте class. С полученными элементами можно будет производить 
//различные манипуляции: менять их текст, атрибуты, CSS стили и так далее.
let elems176_3 = document.getElementsByClassName('www176_3');//применяем метод getElementsByClassName к тегу на странице который имеет класс  'www176_3' записав его значение в переменную
for (let elem176_3 of elems176_3) {//перебираем массив - переменную 
elem176_3.innerHTML = '!!!';//меняем значение каждого тега (записанного в массив) с помощью свойства innerHTML
}

//______________________________
//206 Поиск элементов внутри другого элемента
let parent177 = document.querySelector('#parent177');//передаем querySelector('#parent177') в переменную
let elems177 = parent177.querySelectorAll('.child177');//к этой переменной применяем метод querySelectorAll с параметром '.child177'
for (let elem177 of elems177)//перебираем массив
{
 console.log (elem177.innerHTML)//выводим значения тегов параграфов в консоль
}
//let elems = document.querySelectorAll('#parent .child177');можно найти, выполнив поиск по всему документу с более точным селектором:

//______________________________
//207 Пользовательские атрибуты
//В HTML разрешено добавлять свои, пользовательские атрибуты тегам. Такие атрибуты должны начинаться с data-, а затем должно идти любое название атрибута, которое вам удобно.
//Обращение к таким атрибутам устроено не стандартным образом. Нельзя просто обратиться к одноименному свойству элемента, как мы делали это раньше, а следует использовать специальное свойство dataset, 
//после которого через точку пишется имя атрибута без data-. Например, если наш атрибут называется data-test, то для обращения к нему мы будем писать elem.dataset.test, где elem - переменная с нашим элементом.
let elem178 = document.querySelector('#elem178');//переменной передаем значение тега области
console.log (elem178.dataset.num); // выведет 1000
elem178.dataset.num = 123;//меняем значение нового атрибута
console.log (elem178.dataset.num)// выведет 123

//______________________________
//208 Работа с узлами
//свойства firstChild, lastChild, nextSibling, previousSibling. Эти свойства работают аналогичным образом как свойства firstElementChild, lastElementChild, nextElementSibling, previousElementSibling
//однако, учитывая все узлы.

let elem179 = document.querySelector('#elem179');//присваиваем в переменную значение тега области
console.log(elem179.firstChild);        // применяем к переменной свойство firstChild. Выведет комментарий <!--сomm--> - первый дочерний элемент
console.log(elem179.firstElementChild); // применяем к переменной свойство firstElementChild. Выведет тег span <span>tag</span> - первый дочерний тег
let elem179_1 = document.querySelector('#elem179_1')//присваиваем в переменную значение тега области
console.log (elem179.lastElementChild.innerHTML);// применяем к переменной свойство lastElementChild и InnerHTML. Выведет "2" - последний дочерний тег
console.log (elem179_1.lastChild);//применяем к переменной свойство lastChild -  последний дочерний элемент. Выведет "1"
console.log (elem179_1.nextElementSibling.innerHTML);// применяем к переменной свойство nextElementSibling. Выведет "2" - следующий побратимый тег в этом родителе
console.log (elem179.nextSibling)//выводит следующий тег

//______________________________
//211_1 задача Отработка изученного материала на работу
let elem180_1 = document.querySelector('#elem180_1')
let paragraph180_1 = document.querySelector('#paragraph180_1')
elem180_1.addEventListener('blur', func);
function func() 
{
paragraph180_1.innerHTML = paragraph180_1.innerHTML+elem180_1.value
}

//______________________________
//211_2 задача Отработка изученного материала на работу
let elems180_2 = document.querySelectorAll('.child180_2');
let elem180_22 = document.querySelector('#elem180_22')
button180_2.addEventListener('click', func180_2);//применяем событийный метод
function func180_2 ()
{
let summ180_2 = 0;
for (let elem180_2 of elems180_2) 
{
summ180_2 += Number(elem180_2.value)
}
elem180_22.value = summ180_2
}

//______________________________
//211_3 задача Отработка изученного материала на работу

let elem180_3 = document.querySelector('#elem180_3')
elem180_3.addEventListener('blur', func180_3);//применяем событийный метод
function func180_3 ()
{
let wordMeaning180_3 = elem180_3.value
console.log (wordMeaning180_3)
let result180_3 = 0;
for (let i = 0; i < wordMeaning180_3.length; i++)
{
result180_3 += Number(wordMeaning180_3[i])  ;
}
console.log (result180_3)
}

//______________________________
//211_4 задача Отработка изученного материала на работу
let elem180_4 = document.querySelector('#elem180_4')
elem180_4.addEventListener('blur', func180_4);//применяем событийный метод
function func180_4 ()
{
let wordMeaning180_4 = elem180_4.value
console.log (wordMeaning180_4)
let mass180_4 = (wordMeaning180_4.split (','))
console.log (func180_4_1 (mass180_4))
}
function func180_4_1 (a)
{
let result180_4 = 0;
for (let i = 0; i < a.length; i++)
{
result180_4 += Number(a[i])  ;
console.log (result180_4)
}
console.log (result180_4)
console.log (a.length)
 return result180_4/a.length
}

//______________________________
//211_5 задача Отработка изученного материала на работу

let person180_5 = document.querySelector('#person180_5')
let elems180_5 = document.querySelectorAll('.child180_5');
console.log (elems180_5[0].value)
person180_5.addEventListener('blur', func180_5);
function func180_5 ()
{
let initials180_5 = person180_5.value
let mass180_5 = (initials180_5.split (' '))
console.log (mass180_5)
elems180_5[0].value = mass180_5[0]
elems180_5[1].value = mass180_5[1]
elems180_5[2].value = mass180_5[2]
}

//______________________________
//211_8 задача Отработка изученного материала на работу
let data180_8 = document.querySelector('#data180_8')
data180_8.addEventListener('blur', func180_8);
function func180_8()
{
let datameaning180_8 = data180_8.value
let mass180_8 = datameaning180_8.split('.').reverse().join('-')
data180_8.value = mass180_8
}

//______________________________
//211_9 задача Отработка изученного материала на работу
let elems180_9 = document.querySelector('#element180_9');
let button180_9 = document.querySelector('#button180_9');
button180_9.addEventListener('click', func180_99)
function func180_99()
{
function func180_9()
{
let longWord180_9 = elems180_9.value
return ((longWord180_9.length)/2)
}
let iteration = Math.floor(func180_9())
console.log (iteration)
let a180_9 = ''
for (let i = 0; i <iteration; i++)
{
a180_9 += elems180_9.value[i]
}
console.log (a180_9)
let longWord180_9_2 = elems180_9.value
let b180_9 = ''
for (let j = longWord180_9_2.length-1; j >= longWord180_9_2.length-iteration; j--)
{
b180_9 += elems180_9.value[j]
}
console.log (b180_9)
if (a180_9 === b180_9)
{
console.log ('Симметрия')
elems180_9.style.backgroundColor = '#149F5B'
elems180_9.style.color = '#FFFFFF'
}
else
{
console.log ('Нет симметрии')
elems180_9.style.backgroundColor = '#FF0F0F'
elems180_9.style.color = '#FFFFFF'
}
}

//______________________________
//211_11 задача Отработка изученного материала на работу
let elems180_11 = document.querySelectorAll('.elems180_11');
let button180_11 = document.querySelector('#button180_11');
let length180_11 = elems180_11.length
button180_11.addEventListener('click', func180_11) 
function func180_11()
{
console.log (length180_11)
for (let i = 0; i <length180_11; i++) 
{
elems180_11[i].innerHTML =  i+1 + elems180_11[i].innerHTML
console.log(elems180_11[i].innerHTML)
}
}

//______________________________
//212 Работа с текстареа 
// Тег textarea. При работе с данным тегом есть некоторый нюанс. Суть в следующем: 
//текст, который будет стоять в теге по умолчанию, располагается между открывающем 
//и закрывающем тегом textarea
let elem181_1 = document.querySelector('#elem181_1');// присваиваем переменной значение textarea
console.log(elem181_1.value); // выведет 'text'

//______________________________
//213 Атрибут disabled
//В HTML существуют специальные атрибуты без значений, например, 
//атрибут disabled, используемый для блокировки элементов.
//Для того, чтобы установить такой атрибут, соответствующему 
//свойству требуется присвоить значение true, а чтобы убрать - значение false.

let elem182 = document.querySelector('#elem182');
console.log(elem182.disabled); // выведет true
elem182.disabled = false

let elem182_1 = document.querySelector('#elem182_1');
console.log(elem182_1.disabled); // выведет true
elem182_1.disabled = false
console.log(elem182_1.disabled); // выведет true
elem182_1.disabled = true

//______________________________
//214 Атрибут Работа с чекбоксами 

//Чекбокс представляет собой специальную галочку, которая может находится в двух состояниях: отмечено и нет.
//<input type="checkbox" id="elem">. Чтобы сделать чекбокс отмеченным - ему нужно написать атрибут checked - 
//<input type="checkbox" checked id="elem">:
let elem183_1 = document.querySelector('#elem183_1');// объявляем переменную elem183_1 присвоив значение чекбокса
let button183_1 = document.querySelector('#button183_1');//добавляем первую кнопку 
let button183_2 = document.querySelector('#button183_2');//добавляем вторую кнопку  
button183_1.addEventListener('click', func183_1)//вызываем событие клика на первой кнопке
function func183_1()//исполняем функцию
{
elem183_1.setAttribute('checked', 'true')//добавляем атрибут 
}
button183_2.addEventListener('click', func183_2)//вызываем событие клика на второй кнопке
function func183_2()//исполняем функцию
{
elem183_1.removeAttribute('checked')//удавляем атрибут
}

//______________________________
//215 Чередование атрибутов без значений

let elem184 = document.querySelector('#elem184');// объявляем переменную elem184 присвоив значение области ввода
let button184 = document.querySelector('#button184');//добавляем первую кнопку 
button184.addEventListener('click', function() {//вызываем событие клика на первой кнопке
	if (elem184.disabled  ) //если втрибут disabled присутствует то
	{
		elem184.disabled = false; //присвоить значение false (видится)
		console.log (elem184)
	} 
	else //в противном случае
	{
		elem184.disabled = true;//присвоить значение true (не видится)
		console.log (elem184)
	}
});
//Задачу, однако, можно решить меньшим количеством кода:
//button.addEventListener('click', function() {
//elem.disabled = !elem184.disabled;
//});

//______________________________
//216 Работа с радиокнопками
//В <input type="radio"/>
//Чтобы несколько радиокнопочек были группой, они должны иметь одинаковое значение атрибута name
//Чтобы сделать какую-нибудь радиокнопку отмеченной по умолчанию, ей необходимо задать атрибут checked
//let radios185 = document.querySelectorAll('input[name="elem185"]');

let radios185 = document.querySelectorAll('.elem185');//объявляем в переменную группу радиокнопок по классу
let button185 = document.querySelector('#button185');//объявляем кнопку
button185.addEventListener('click', function() { //присваиваем событие кнопке
	for (let radio185 of radios185) {//создаем цикл перебора массива кнопок из переменной
		if (radio185.checked) {//если в элементе есть атрибут checkeded то
			console.log(radio185.value); //вывести значениев консоль
		}
	}
});

//______________________________
//217 Событие change
//change возникает в полях ввода при их изменениях.
let elem186 = document.querySelector('#elem186');//объявляем переменную elem186 присвоив значение области ввода
elem186.addEventListener('change', function() {// присваиваем событие 'change' в переменную elem186
	console.log(this.value);//вывести в консоль значение которое ввели но по потере фокуса
});

//______________________________
//218 Событие input
//возникает каждый раз при вводе нового символа в инпут или textarea.
let elem187 = document.querySelector('#elem187');//объявляем переменную elem187 присвоив значение области ввода
elem187.addEventListener('input', function() {// присваиваем событие 'input' в переменную elem187
console.log(this.value);//выводит в консоль значение которое сразу ввели в область (изменение)
});

//______________________________
//219 Методы focus и blur
//В JavaScript существуют специальные методы, которые позволяют принудительно установить фокус в инпут или убрать его оттуда. 
//Это методы focus и blur.

let elem188   = document.querySelector('#elem188');// присваиваем переменной значение области ввода
let button188_1 = document.querySelector('#button188_1'); //присваиваем переменной значение кнопки
let button188_2 = document.querySelector('#button188_2');//присваиваем переменной значение кнопки
	button188_1.addEventListener('click', function() { //при нажатие на кнопку клика мыши срабатывает событие фокуса на области ввода
		elem188.focus() //фокус на области ввода
		console.log('фокус')	//выводит в консоль слово "фокус"
		})
	button188_1.addEventListener('dblclick', function() {//при нажатие на кнопку клика мыши срабатывает событие потери фокуса на области ввода
		elem188.blur() //потеря фокуса на области ввода
		console.log('размытие')//выводит в консоль слово "размытие"
		})

//______________________________
//220 Работа с выпадающими списками 
//тег select представляет собой выпадающий список. 
//c помощью  атрибута value можно получать выбранный пункт списка
//Пунктам списка можно добавить атрибут value. В этом случае свойство value селекта будет содержать не текст option, 
//а значение его атрибута value. select можно превратить в мультиселект с помощью атрибута multiple, в этом случае можно 
//выбирать несколько элементов списка а сам список становится развернутым со скроллом. С помощью атрибута selected можно 
//выбрать элемент списка по умолчанию (будет выбран в селекте в области или подкрашен в мультиселекте)
let select189 = document.querySelector('#select189'); //  присваиваем переменной значение области списка
select189.addEventListener('change', function(){//при изменении значения списка срабатывает событие изменения 
	console.log(select189.value);//вывод выбранного значения списка в консоль
});

//______________________________
//221 Изменение выбранного пункта списка
//Можно применять свойство value к селекту, записав новое значение атрибута value у выбранного элемента option
let select190 = document.querySelector('#select190'); //  присваиваем переменной значение области списка
let button190 = document.querySelector('#button190'); //  присваиваем переменной значение кнопки
button190.addEventListener('click', function() { //привязываем к кнопке событие клика к списку
	//select190.value = 'one'; //значение списка изменить на 'one' (это не меняет сам список, для изменение самого списка нужно 
	//использовать метод setAttribute ('атрибут','значение')
	let children190 = select190.children
	for (let child190 of children190) {//циклом перебираем элементы
	child190.setAttribute('value', 'one')
	console.log(select190.value)
	}
});

//______________________________
//221_1 Изменение выбранного пункта списка
let date = new Date(); // добавляем новый объект дату
let Month =(date.getMonth() + 1);    // применяем к объекту дата метод getMonth(), который определяет текущий месяц (от 0 до 11)
console.log ( Month )// выводим месяц
let select190_1 = document.querySelector('#select190_1'); // объявляем переменную присвоив значение списка
let children190_1 = select190_1.children //объявляем переменную записав туда массив тегов входящих в родительский тег списка с 
//помощью свойства children к переменной select190_1
for (let child190_1 of children190_1) {// перебор массива 
if (child190_1.value == Month) // проверка - условие если текущий элемент массива (значение элемента списка) = текущему месяцу
{
console.log(child190_1.value) // вывести в консоль 
child190_1.setAttribute('selected','true'); //добавляем к текущему элементу массива атрибут 'selected'
}
}

//______________________________
//222 Номер выбранного пункта выпадающего списка
//В селектах существует специальное свойство selectedIndex, хранящее в себе номер того пункта списка, который сейчас выбран. 
//Нумерация при этом начинается с нуля. 
//При этом данное свойство можно как прочитывать, так и записывать, меняя выбранный пункт списка.
let select191 = document.querySelector('#select191');// // объявляем переменную присвоив значение списка
console.log(select191.selectedIndex); //выводим в консоль порядковый номер (из массива) текущего выбранного элемента списка 
//select191.selectedIndex = 5; // выберет 'июнь'- с помощиью свойства selectedIndex можно задать выбор элемента списка

//______________________________
//223 Получение пунктов выпадающего списка
//можно разными способами 
/* 
let options192 = document.querySelectorAll('#select192 option')// объявляем переменную которой передаем массив из тегов 'option'
for (let option192 of options192) {//циклом перебираем элементы //циклом перебираем теги
console.log(option192.value)// в консоль выводим значения элементов массива
*/

/*
let select192 = document.querySelector('#select192');	 // в переменную записываем значение списка
let options192 = select192.querySelectorAll('option'); //применяем к переменной метод querySelectorAll () - 
//получаем массив входящих тегов
for (let option192 of options192) {//циклом перебираем теги
console.log(option192.value)// в консоль выводим значения элементов массива
}
*/

let select192 = document.querySelector('#select192');// в переменную записываем значение списка
for (let option of select192) {//циклом перебираем теги
console.log(option.value);// в консоль выводим значения элементов массива
}
console.log(select192[5].value);//выведем в консоль значение 6 элемента списка

//______________________________
//224 Работа с пунктами выпадающего списка
let select193 = document.querySelector('#select193');// в переменную записываем значение списка
let option193_1 = select193[5];//в переменную записываем значение 5 элемента списка - option
console.log(option193_1.text); // применяем свойство text, выведет 'июнь'
console.log(option193_1.value); // применяем свойство атрибута value, выведет 6 
console.log(option193_1.selected); // применяем свойство атрибута selected,  выведет true
//Можно взять и непосредственно какому-нибудь тегу option установить свойство selected в значении true.
let option193_2 = select193[2];
option193_2.selected = true; 
console.log(select193[select193.selectedIndex]); //выведет <option value="3">март</option>

//______________________________
//225_11  Работа с ползунком
let size193_11 = document.querySelector('#elem193_11');// передаем переменной значение ползунка по id
let elem193_12 = document.querySelector('#elem193_12');// передаем переменной значение инпута
console.log (elem193_12.value)//вывести в консоль значение элемента
size193_11.addEventListener('change', func193_11) // при изменении ползунка применяется функция
function func193_11() {
console.log (size193_11.value)// вывести в консоль значение ползунка
elem193_12.value = Number(size193_11.value)// значение инпута равно значению ползунка
};

//______________________________
//226 Основы работы с объектом Event
//объект Event содержит в себе информацию о произошедшем событии. К примеру, 
//если по элементу был сделан клик, мы можем узнать координаты этого клика, 
//была ли нажата клавиша Ctrl, Alt или Shift в момент клика и так далее.
let elem194 = document.querySelector('#elem194'); // передаем переменной значение 
//ползунка по id
elem194.addEventListener('click', function(event) {  // при клике выполняем событие, 
//применяя функцию и передавая ей параметр (параметр может быть любой)
//в этот параметр запишется объет event, его можно будет вызвать
console.log(event);// запишем в консоль объект event (событие)
});

//______________________________
//227 Координаты события
//Свойство event.clientX содержит в себе координаты курсора мыши по оси X.
//Для определения координат есть также свойства event.clientY, event.pageX, event.pageY.
let elem195 = document.querySelector('#elem195'); //создаем переменную с дивом
document.addEventListener('mousemove', function(event) { // вызываем к переменной 
//событие движения мыши при котором выполняется функция event
elem195.innerHTML = event.clientX + ' : ' + event.clientY; //в значение дива 
//записываем координаты мыши по х и у при помощи событий примененных к объекту event
// (по аналогии с датами)
});

//______________________________
//228 Тип события в объекте Event
//Объект Event также содержит в себе тип произошедшего события. Под типом понимается 
//название click, mouseover и так далее. Тип события содержит свойство type:
let button196 = document.querySelector('#button196')// передаем переменной значение 
//области ввода по id
button196.addEventListener('click', function(event) // вызываем к переменной событие
// клика мыши  при котором выполняется функция event
{
console.log (event.type)// выведет 'click' если к объекту event применить событие type
})


//______________________________
//229 Элемент события в объекте Event
//Объект Event также позволяет получить элемент, в котором произошло событие. 
//Этот элемент содержится в свойстве target.
//на самом деле this всегда содержит элемент, к которому было привязано событие, 
//а свойство target - элемент, по которому реально был клик. 
//Свойство tagName содержит имя тега в верхнем регистре (большими буквами).
let elem197 = document.querySelector('#elem197');

elem197.addEventListener('click', function(event) {// вызываем к переменной событие 
//клика мыши при котором выполняется функция с параметром event
console.log(event.target); // выведет наш абзац - <p>text</p>
console.log(this);         // выведет наш див - <div id="elem197"></div>
console.log(elem197.tagName); // выведет DIV
console.log(event)
});

//______________________________
//230 Получение нажатых клавиш
//Событие keydown происходит при нажатии клавиши, а keyup – при отпускании.
//Свойство key объекта события позволяет получить символ, а свойство code – 
//«физический код клавиши».
//К примеру, одну и ту же клавишу Z можно нажать с клавишей Shift и без неё. 
//В результате получится два разных символа: z в нижнем регистре и Z в верхнем регистре.
//Буквенные клавиши имеют коды по типу "Key<буква>": "KeyA", "KeyB" и т.д.
//Коды числовых клавиш строятся по принципу: "Digit<число>": "Digit0", "Digit1" и т.д.
//Код специальных клавиш – это их имя: "Enter", "Backspace", "Tab" и т.д.
/*
document.addEventListener('keydown', function(event) {// вызываем к переменной 
//событие нажатия клавиши при котором выполняется функция с параметром event
if (event.code == 'KeyZ') //условие,  если нажатая клавиша( свойство code) 
//равна клавиши z – «физический код клавиши» то...
{
console.log ('z')
}
if (event.code == "ArrowUp") //условие,  если нажатая клавиша( свойство code) 
//равна клавиши стрелки вверх (ArrowRight, ArrowUp, ArrowLeft, ArrowDown)  –
// «физический код клавиши» то...
{
console.log ('вверх')
}
})
*/
//______________________________
//231 Отслеживание клавиш-модификаторов 
//помощью объекта Event можно узнать, были ли нажаты в момент события клавиши 
//Ctrl, Alt и Shift. Это делается с помощью свойств ctrlKey, altKey и shiftKey - 
//они имеют значение true или false в зависимости от того, была ли нажата эта 
//клавиша в момент события или нет.
let elem199 = document.querySelector('#elem199'); //создаем переменную с кнопкой
elem199.addEventListener('click', function(event) {// вызываем к переменной событие клика 
//по кнопке при котором выполняется функция с параметром event
	if (event.ctrlKey) { //если нажат контрол выведет сообщение
		alert('нажат Ctrl');
	}
	if (event.altKey) {
		alert('нажат Alt');//если нажат альт выведет сообщение
	}
	if (event.shiftKey) {
		alert('нажат Shift');//если нажат сшифт выведет сообщение
	}
});

//______________________________
//232 Отмена действия по умолчанию
//Отмена действия тега по умолчанию с помощью объекта Event. Для этого у него 
//есть специальный метод preventDefault(), который следует вызвать в любом
// месте обработчика события.
let elem200 = document.querySelector('#elem200');//создаем переменную с ссылкой
elem200.addEventListener('click', function(event) {// вызываем к переменной событие 
//клика по ссылке при котором выполняется функция с параметром event
	event.preventDefault();//метод preventDefault() отменяет (блокирует тег)
	alert('Вы не можете перейти по этой ссылке!');// выводит на экран
});

//______________________________
//232_1 Практика управление перемещения
let select200_4 = document.querySelector('#elem200_4'); 
let elem200_1 = document.querySelector('#elem200_1')
select200_4.addEventListener('change', func200_4)
function func200_4 ()
{
elem200_1.src = select200_4.value
console.log (elem200_1.src)
select200_4.blur()
};
let u = 6 
let size200_3 = document.querySelector('#elem200_3');
size200_3.addEventListener('change', func200_3)
function func200_3() 
{
u = Number(size200_3.value)
size200_3.blur()
};
let y200_1 = 0
let x200_1 = 0
document.addEventListener('keydown', control)
function control(event)
{
elem200_1.style.position = 'relative'
if (event.code == "KeyS"  && y200_1 + u >= -700) 
{
elem200_1.style.transition = 'transform 1s'
elem200_1.style.transform = 'rotate(180deg)'
y200_1 -= u 
console.log ( y200_1)
console.log ( x200_1)
elem200_1.style.bottom = y200_1 + 'px'
console.log ('вниз')
}
if (event.code == "KeyW" && y200_1 - u  < 0) 
{
elem200_1.style.transition = 'transform 1s'
elem200_1.style.transform = 'rotate(0deg)'
y200_1 += u 
console.log ( y200_1)
console.log ( x200_1)
elem200_1.style.bottom = y200_1 + 'px'
console.log ('вверх')
}
if (event.code == "KeyA" && x200_1 + u >= 0) 
{
elem200_1.style.transition = 'transform 1s'
elem200_1.style.transform = 'rotate(270deg)'
x200_1 -= u
console.log ( y200_1)
console.log ( x200_1)
elem200_1.style.left = x200_1 + 'px'
console.log ('влева')
}
if (event.code == "KeyD"  && x200_1 - u < 700) 
{
elem200_1.style.transition = 'transform 1s'
elem200_1.style.transform = 'rotate(90deg)'
x200_1 += u
console.log ( y200_1)
console.log ( x200_1)
elem200_1.style.left = x200_1 + 'px'
console.log ('вправа')
}
}

//______________________________
//233 Всплытие событий
//Несколько вложенных друг в друга блоков, при клике на идин из элементов 
//событие сначала сработает в красном блоке, потом в голубом, потом в зеленом.
//Кликая на внутренний блок, вы одновременно кликаете на все внешние.
//Такое поведение называется всплытием (англ. bubbling) событий
let elem201_1 = document.querySelector('#elem201_1');// создаем переменную присвоив ей значение элемента области 
let elem201_2 = document.querySelector('#elem201_2');// создаем переменную присвоив ей значение элемента области 
let elem201_3 = document.querySelector('#elem201_3');// создаем переменную присвоив ей значение элемента области 
elem201_1.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('зеленый');//вывод на экран 
});
elem201_2.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('голубой');//вывод на экран 
});
elem201_3.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('красный');//вывод на экран 
});

//______________________________
//234 Получение целевого элемента при всплытии событий
//Объект Event также позволяет получить элемент, в котором произошло событие. 
//Этот элемент содержится в свойстве target.
//на самом деле this всегда содержит элемент, к которому было привязано событие, 
//а свойство target - элемент, по которому реально был клик. 
//Свойство tagName содержит имя тега в верхнем регистре (большими буквами).
let elem202 = document.querySelector('#elem202');//в переменную записывает, передаем область 
elem202.addEventListener('click', function(event) {//к переменной применяем событие клика
	alert('click');
	console.log(this); // При клике на div (область ) выведет див
	console.log(elem202.tagName)//При клике на div или P (область или абзац)  выведет DIV 
	console.log(event.target)//Выведет элемент по которому реально был клик (выведет синтаксис HTML тега p или div  
	if (event.target.tagName === 'DIV') {// можно применить дав этих события к объекту event и получить реальный тег клика
		alert('клик именно по диву');
	}
	if (event.target.tagName === 'P') {//
		alert('клик именно по абзацу');
	}
});
//Mожно вместо tagName использовать Метод matches: -позволяет проверить, удовлетворяет ли элемент указанному CSS селектору.
/*<p id="elem" class="www"></p>
let elem = document.querySelector('#elem');
console.log(elem.matches('p.www'));  //выведет true */

//______________________________
//235 Прекращение всплытия событий
//Всплытие события можно остановить на любой элемент, через который всплывает событие. 
//Для этого в коде элемента следует вызвать метод stopPropagation объекта Event.
let elem203_1 = document.querySelector('#elem203_1');// создаем переменную присвоив ей значение элемента области 
let elem203_2 = document.querySelector('#elem203_2');// создаем переменную присвоив ей значение элемента области 
let elem203_3 = document.querySelector('#elem203_3');// создаем переменную присвоив ей значение элемента области 
elem203_1.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('зеленый');//вывод на экран 
});
elem203_2.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('голубой - второй обработчик'); //вывод на экран 
	event.stopImmediatePropagation()// остановим всплытие всех последующих 
});
elem203_2.addEventListener('click', function(event) {//к переменной применяем событие клика, которая вызывает функцию
	alert('голубой');//вывод на экран 
	event.stopPropagation(); // остановим всплытие кроме текущего элемента
});
elem203_3.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('красный');//вывод на экран 
});
//Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.
//То есть, stopPropagation препятствует продвижению события дальше, но на текущем элементе все обработчики отработают. 
//Для того, чтобы полностью остановить обработку, современные браузеры поддерживают метод stopImmediatePropagation.
//Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе

//______________________________
//236 Погружение событий
//Кроме всплытия событий есть еще и погружение. На самом деле событие сначала идет сверху вниз (стадия перехвата), 
//доходит до нашего элемента (стадия цели) и только потом начинает всплывать (стадия всплытия).
//Для того, чтобы повесить обработчик события с учетом стадии перехвата в addEventListener есть третий необязательный параметр. 
//Если он равен true - событие сработает на стадии перехвата, а если false - на стадии всплытия (это по умолчанию). 
let elem204_1 = document.querySelector('#elem204_1');// создаем переменную присвоив ей значение элемента области 
let elem204_2 = document.querySelector('#elem204_2');// создаем переменную присвоив ей значение элемента области 
let elem204_3 = document.querySelector('#elem204_3');// создаем переменную присвоив ей значение элемента области 
elem204_1.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('зеленый - погружение');//вывод на экран 
}, true);
elem204_1.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('зеленый - всплытие');//вывод на экран 
}, false);
elem204_2.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('голубой - погружение');//вывод на экран 
}, true);
elem204_2.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('голубой - всплытие');
}, false);
elem204_3.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('красный - погружение');//вывод на экран 
}, true);
elem204_3.addEventListener('click', function() {//к переменной применяем событие клика, которая вызывает функцию
	alert('красный- всплытие');//вывод на экран 
}, false);

//______________________________
//237 Навешивание обработчиков на новые элементы
//Навешивание обработчиков осуществляются методами appendChild(item) и document.createElement('li')

let button205_1 = document.querySelector('#button205_1');//создем переменную кнопки
let elem205  = document.querySelector('#elem205'); //создем переменную списка
let items  = elem205.querySelectorAll('.class205'); //создаем перемнную (массив) со списком классов
button205_1.addEventListener('click', function() {//при нажатии
	let item = document.createElement('li');//В HTML-документах создаёт элемент c тем тегом, что указан в аргументе 
	//или HTMLUnknownElement, если имя тега не распознаётся.
	item.innerHTML = 'item';// в переменную item записываем значение 'item'
	this.innerHTML = this.innerHTML + '!';//переименовываем
	elem205.appendChild(item);// добавляет узел в конец списка дочерних элементов указанного родительского узла.
	//Node.removeChild (Удаляет дочерний элемент из DOM. Возвращает удалённый элемент.), Node.replaceChild (Заменяет дочерний элемент), 
	//Node.insertBefore (добавляет элемент в  список дочерних элементов родителя перед указанным элементом) Node.hasChildNodes 
	//(Возвращает Boolean значение показывающее имеет ли текущий Node дочерние узлы или нет)
});

//______________________________
//238 Делегирование событий 
let button206_1 = document.querySelector('#button206_1');;//создем переменную кнопки
let list206_1   = document.querySelector('#elem206');//создем переменную списка
let items206_1  = list206_1.querySelectorAll('.class206');//создаем перемнную (массив) со списком классов
list206_1 .addEventListener('click', function(event) {//при нажатии
	console.log(this);         // при нажатии на список ul выводим наш список
	console.log(event.target); // при нажатии на список ul выводим тег где было произведено событие - li
	event.target.innerHTML = event.target.innerHTML + '!'; // изменяем значение у полученного тега где был клик
});

//______________________________
//239  Основы работы с контекстом
//функция func, внутри которой используется this
let elem207_1 = document.querySelector('#elem207_1');// создаем перемннную с областью ввода
elem207_1.addEventListener('blur', func);//к переменной применяем событие при потере фокуса исполнить функцию
let elem207_2 = document.querySelector('#elem207_2');// создаем перемннную с областью ввода
elem207_2.addEventListener('blur', func);//к переменной применяем событие при потере фокуса исполнить функцию
function func() {
	console.log(this.value); // выведет или 'text1', или 'text2' 
}

//______________________________
//240  Контекст непривязанной функции
//этом случае результат зависит от того, строгий у нас режим или нет. Если режим нестрогий, то в this будет хранится ссылка на window, 
//а если режим строгий, то в this будет хранится undefined.
//В любой функции можно написать this, это не приведет к каким-либо ошибкам JavaScript. Но вот что именно будет лежать в этом this не
// определено до момента вызова функции. Причем при разных вызовах функции this может принимать разное значение. Все зависит от контекста, 
//в котором была вызвана функция.
function func208() {
	console.log(this);
}
func208();// ссылка на окно window

//______________________________
//241  Потеря контекста
//первый console.log выведет в консоль ссылку на наш инпут, а второй - просто undefined. Такая ситуация, когда this неожиданным для нас 
//образом указывает не на то, что нам нужно, называется потеря контекста.
let elem209 = document.querySelector('#elem209');// создаем перемннную с областью ввода
elem209.addEventListener('blur', parent);//к переменной применяем событие при потере фокуса исполнить функцию
function parent() {
	console.log(this.value); // выведет ссылку на наш инпут 
	function child() {
		console.log(this); // ссылка на окно window
	}
	child();//вызываем функцию
}

//______________________________
//242  Решение проблемы с контекстом
//первое решение - запишем this в любую переменную 
let elem210 = document.querySelector('#elem210');// создаем перемннную с областью ввода
elem210.addEventListener('blur', parent210);//к переменной применяем событие при потере фокуса исполнить функцию
function parent210() {
	console.log(this.value); // выведет 'text'
	let self = this; // запишем this в любую переменную, например, в self 
	function child210() {
		console.log(self.value); // выведет 'text'
	}
	child210();
}
//второе решение  - функция child принимала параметр
let elem210_1 = document.querySelector('#elem210_1');// создаем перемннную с областью ввода
elem210_1.addEventListener('focus', parent_1);//к переменной применяем событие при потере фокуса исполнить функцию
function parent_1() {
	child210_1(this); // передаем параметром this
	function child210_1(param) {
		console.log(param.value); // выводим value инпута
	}
}

//третье решение проблемы заключается в использовании стрелочных функций. 
//Такие функции, помимо всего прочего, не имеют своего контекста, а сохраняют контекст родителя.
// Исправим нашу проблему с помощью стрелочной функции:
/*let elem = document.querySelector('#elem');
elem.addEventListener('blur', parent);
function parent() {
	console.log(this.value); // выведет 'text'
	let child = () => {
		console.log(this.value); // выведет 'text'
	}
	child();
}
*/

//______________________________
//243  Привязывание контекста через метод call
//Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами.
// Синтаксис - fun.call(thisArg[, arg1[, arg2[, ...]]]). Пока наша функция не знает, на что ссылается this. 
//Вот, если бы мы ее привязали через addEventListener, тогда да. Но мы не будем этого делать. 
//В замен мы просто вызовем нашу функцию, сказав ей, что this должен быть равен elem.
//Это делается вот так: func.call(elem). Этот код эквивалентен простому вызову функции func вот так: func(), 
//только с условием, что this равен elem.
let elem211_1 = document.querySelector('#elem211_1');// создаем перемннную с областью ввода
let elem211_2 = document.querySelector('#elem211_2');// создаем перемннную с областью ввода
let elem211_3 = document.querySelector('#elem211_3');// создаем перемннную с областью ввода
function func211_1() {//объявляем фукцию
console.log(this.value);// передаем параметром this значение которое пренадлежит элементу к которому применена функция
}
func211_1.call(elem211_1);//метод call применяется к функциям, указывает на конкретный элемент к которому применяется 
//функция (заменяет this, казав ей, что this должен быть равен elem)
func211_1.call(elem211_2);//метод call применяется к функциям, указывает на конкретный элемент к которому применяется 
//функция (заменяет this, казав ей, что this должен быть равен elem)
func211_1.call(elem211_3);//метод call применяется к функциям, указывает на конкретный элемент к которому применяется 
//функция (заменяет this, казав ей, что this должен быть равен elem)
let elem211 = document.querySelector('#elem211');// создаем перемннную с областью ввода
func211.call(elem211, 15, 25);//метод call применяется к функциям, указывает на конкретный элемент к которому применяется 
//функция (заменяет this, казав ей, что this должен быть равен elem)
function func211(param1, param2) {//объявляем фукцию с параметрами
console.log(Number(this.value) +  param1 + param2); // передаем параметром this значение которое пренадлежит элементу 
//к которому применена функция и выводим в консоль сумму
}

//______________________________
//244  Привязывание контекста через метод apply
//Давайте теперь рассмотрим метод apply для привязывания контекста. Он работает практически так же, 
//как и метод call. Разница заключается в том, что в apply параметры передаются в виде массива,
// а не перечисляются через запятую. В зависимости от задачи бывает удобен то один, то другой метод.
//Вот пример передачи параметров в метод apply:
//func.apply(elem212, [param1, param2]);

//______________________________
//245  Привязывание контекста через метод bind
//Метод bind позволяет навсегда привязать контекст к функции. Своим результатом этот метод возвращает новую функцию, 
//внутри которой this будет иметь жестко заданное значение. Синтаксис - fun.bind(thisArg[, arg1[, arg2[, ...]]])

let elem213 = document.querySelector('#elem213');// создаем перемннную с областью ввода
let qwert213 = func213.bind(elem213);//метод bind применим к области ввода, определяет тег к которому применяется функция
function func213(par1, par2) {//объявляем фукцию с параметрами
console.log(this.value +  par1 + par2); 
}// передаем параметром this значение которое пренадлежит элементу 
//к которому применена функция и выводим в консоль сумму
qwert213('15', '25')//передаем функции параметры

//______________________________
//246  Основы работы с функцией setInterval
//Для работы с таймерами в JavaScript используется функция setInterval, которая запускает заданный код через определенные промежутки времени.
//Эта функция работает следующим образом: первым параметром она принимает исходный код функции, а вторым параметром - интервал, через который 
//эта функция будет автоматически вызываться. Второй параметр задается в миллисекундах (1000 миллисекунд = 1 секунда).
let elem214 = document.querySelector('#elem214')// создаем перемннную с областью ввода
setInterval(timer, 1000)//встроенная функция setInterval вызывает функцию timer с интервалом в 1 секунду ; 
function timer() {// создаем функцию 
elem214.value = (Number(elem214.value) + 1)//изменяем значение области ввода на 1 с каждой секундой (счетчик секундомер)
}

//______________________________
//247  Счетчик через функцию setInterval
//let i215 = 0;//объявляем переменную
//setInterval(function() {//вызываем встроенную функцию
//console.log(++i215);//при каждом вызове прибавляем + 1 к переменной  i215
//}, 1000);

//______________________________
//248  Счетчик через функцию setInterval Остановка таймера
//синтаксис - clearInterval(intervalID)
//Для остановки таймера используется функция clearInterval, которая принимает уникальный номер того таймера, который нужно остановить.
let i216 = 0; // объявляем счетчик
let timerId216 = setInterval(function() { // создаем переменную в которую записываем встроенную функцию setInterval, 
//которая в параметры принимает  необъявленную функцию с значением в милисекундах
	console.log(++i216);//выполнение функции вывод в консоль счетчика
//alert(timerId216); // выведет номер таймера на экран
if (i216 >= 0) { // условие если счетчик равен 10 то (0 поставил чтоб в консоли и на экран не выводило)
		clearInterval(timerId216);// применяем функцию clearInterval которая параметром получает порядковый номер счетчика - clearInterval(intervalID)
	}
}, 1000);

//______________________________
//249 Кнопка для запуска таймера на JavaScript

let elem217 = document.querySelector ('#elem217')// объявляем счетчик
elem217.addEventListener ('click', func217)// к переменной привязываем событие клика по которому исполняется функция func217
function func217()//объявляем функцию func217
{
elem217.removeEventListener('click', func217); //метод removeEventListener запрещает событие клика и выполнение функции
	let i217 = 0;//создаем переменную счетчик
	setInterval(func217_1, 1000)// метод setInterval запускает функцию из своих параметров с частотой в милисекундах, которые прописаны во втором параметре метода
	function func217_1() // объявляем функцию func217_1
	{
		console.log(++i217);//функция func217_1 выводит в консоль значение счетчика
	}
}

//______________________________
//250 Кнопки для запуска и остановки таймера
let elem218_1 = document.querySelector('#elem218_1');//создаем переменную куда вписываем значение области ввода
let elem218_2 = document.querySelector('#elem218_2');//создаем переменную куда вписываем значение кнопки
let elem218_3 = document.querySelector('#elem218_3');//создаем переменную куда вписываем значение кнопки
let elem218_4 = document.querySelector('#elem218_4');//создаем переменную куда вписываем значение кнопки
let timerId218; // сделаем переменную глобальной для того чтобы она виделась во вложенной функцыии
elem218_2.addEventListener('click', func218)//вешаем событие клика на кнопку с функцией
let i218 = 1 //создаем счетчик 
function func218()//создаем функцию 
{
if (elem218_1.value == 0) //условие если значение области ввода равно 0
{
elem218_2.removeEventListener('click', func218);// метод removeEventListener запрещает событие клика и выполнение функции
timerId218 = setInterval(func218_1,1000)// метод setInterval запускает функцию из своих параметров с частотой в милисекундах, которые прописаны во втором параметре метода
function func218_1()//объявляем функцию
{
elem218_1.value = i218++//значение области ввода равна i218 плюс 1
}
}
}
elem218_3.addEventListener('click', func218_2)//вешаем событие клика на кнопку с функцией
function func218_2()//создаем функцию 
{
clearInterval(timerId218);//останавливаем таймер с помощью метода clearInterval у которого в параметре id счетчика 
}
elem218_4.addEventListener('click', func218_3)//вешаем событие клика на кнопку с функцией
function func218_3()//создаем функцию 
{
elem218_1.value = 0//передаем в значение области ввода 0
i218 = 1//таймер сбрасываем 
elem218_2.addEventListener('click', func218)//создаем событие кликак заново
}
//______________________________
//251 Практика на таймеры и работу с DOM в JavaScript

let elem219 = document.querySelector('#elem219');//создаем переменную области ввода 
setInterval(function() {
	elem219.value = Number(elem219.value) + 1;
}, 1000);//создаем таймер куда в первый параметр записана функция добавление счетчика а во ворой интервал

//______________________________
//252 Таймеры и потеря контекста
//Функция в функции: есть внешняя анонимная функция, которая вызывается по клику и внутренняя анонимная функция,
// которую запускает таймер. Во внешней функции this указывает на инпут, но во внутренней - нет. Имеет место потеря контекста.
let elem220 = document.querySelector('#elem220');//зодаем переменную область ввода 
elem220.addEventListener('click', function() {//к переменной навешиваем событие клика
	let self = this;//в переменную записываем  значение ключевого слова this указывающего на elem220
	setInterval(function() {
		console.log(self.value);
	}, 1000);//запускаем таймер выводящий к консоль значение тега из this
});

//______________________________
//253 Передача контекста параметром функции setInterval
//setInterval имеет малоизвестный синтаксис, позволяющий решить описанную в предыдущем уроке проблему с контекстом.
//Суть в том, что кроме первых двух параметров в setInterval можно передавать еще дополнительные параметры.
//Эти дополнительные параметры попадут в параметры привязанной функции.
let elem221 = document.querySelector('#elem221');//задаем переменную область ввода 
elem221.addEventListener('click', function() {// привязвыаем событие клика к переменной - исполнение функции 
setInterval(func221, 1000, this, 'b', 'c');//функция запускает счетчик который исполняет вложенную функцию с переданными параметрами в том числе this
function func221(str1, str2, str3) {//объявление функции с 3 пaраметрами
console.log(str1.value, str2, str3); // каждую секунду будет вводить кнопка(значение кнопки) b c
}
});

//______________________________
//254_2 Практика на таймеры и работу с DOM
let elem222_2 = document.querySelector('#elem222_2');//задаем переменную кнопки
let elem222_22 = document.querySelector('#elem222_22');//задаем переменную абзаца
elem222_2.addEventListener('click', func222_2)//вешаем на переменную событие клика кнопки
function func222_2()//объявляем функцию события кнопки
{
let timerId222_2//создаем переменную куда будем выводить значение счетчика 
timerId222_2 = setInterval(func222_22,1000)//передаем в переменную id счетчика (объявление счетчика)
function func222_22()//исполняем функцию счетчика
{
elem222_22.innerHTML = elem222_22.innerHTML - 1;//значение абзаца с каждой итерацией уменьшам на 1
if (elem222_22.innerHTML == 0) //если значение абзаца равен 0 то 
{ 
clearInterval(timerId222_2);//остановка счетчика
}
}
}

//______________________________
//254_4 Практика на таймеры и работу с DOM
let elem222_4 = document.querySelector('#elem222_4');//задаем переменную область ввода 
let elem222_44 = document.querySelector('#elem222_44');//задаем переменную параграфа
elem222_4.addEventListener('blur', func222_4)//вешаем к переменной области ввода событие ввода функцию 
function func222_4()// задаем функцию счетчика
{
elem222_44.innerHTML = (elem222_4.value)//указываем что значение области параграфа равен значению области ввода
let timerId222_4 //создаем переменную счетчик
timerId222_4 = setInterval(func222_44,1000)//передаем в переменную id счетчика
function func222_44()//объявляем функцию счетчика
{
elem222_44.innerHTML = elem222_44.innerHTML - 1;//значение абзаца с каждой итерацией уменьшам на 1
if (elem222_44.innerHTML == 0) //если значение абзаца равен 0 то 
{ 
clearInterval(timerId222_4);//остановка счетчика
}
}
}

//______________________________
//254_6 Практика на таймеры и работу с DOM

let elem222_61 = document.querySelector('#elem222_61');//создаем переменную куда вписываем значение области ввода
let elem222_62 = document.querySelector('#elem222_62');//создаем переменную куда вписываем значение кнопки
let elem222_63 = document.querySelector('#elem222_63');//создаем переменную куда вписываем значение кнопки

let timerId222_6; // сделаем переменную глобальной для того чтобы она виделась во вложенной функцыии
elem222_62.addEventListener('click', func222_6)//вешаем событие клика на кнопку с функцией
let i222_6 = 1 //создаем счетчик 
function func222_6()//создаем функцию 
{
if (elem222_61.value == 0) //условие если значение области ввода равно 0
{
elem222_62.removeEventListener('click', func222_6);// метод removeEventListener запрещает событие клика и выполнение функции
timerId222_6 = setInterval(func222_61,1000)// метод setInterval запускает функцию из своих параметров с частотой в милисекундах, которые прописаны во втором параметре метода
function func222_61()//объявляем функцию
{
elem222_61.value = i222_6++//значение области ввода равна i218 плюс 1
}
}
}
elem222_63.addEventListener('click', func222_62)//вешаем событие клика на кнопку с функцией
function func222_62()//создаем функцию 
{
clearInterval(timerId222_6);//останавливаем таймер с помощью метода clearInterval у которого в параметре id счетчика 
}

//______________________________
//254_8 Практика на таймеры и работу с DOM
let date22_8 = new Date()//созаем объект с датой
let h222_8 = (date22_8.getHours());    // часы
let m222_8 = (date22_8.getMinutes());  // минуты
let s222_8 = (date22_8.getSeconds());  // секунды
let elem222_8 = document.querySelector('#elem222_8')
setInterval(funcs222_8,1000) //создаем счетчик интервал
function funcs222_8()//объявляем функцию интервала
{
if (s222_8 < 61)//если секунд меньше 60 идет счетсчик интервал припрост секунд
{
s222_8++
}
if (s222_8 == 61)//если секунды равны 60 то 
{
s222_8 = 1//обнуление счетчика
m222_8++//минуты увеличиваются на 1
}
if (m222_8 == 60)//если минут 60 
{
m222_8 = 0//обнуляем счетчик
h222_8++//часы на 1 плюс
}
if (h222_8 == 24)//если часы равны 24 то
{
h222_8 = 0//обнуляем счетчик часов
}
elem222_8.innerHTML = h222_8+':'+m222_8+':'+s222_8//выводим в значение параграфа с тикающимичасами 
}

//______________________________
//255 Метод setTimeout
//Метод setTimeout, которая позволяет сделать задержку перед запуском кода. Эта задержка, в отличии от функции setInterval, случится только один раз.
//Первым параметром setTimeout принимает исходный код функции, а вторым - задержку в миллисекундах перед запуском этой функции.
let elem223 = document.querySelector('#elem223');//создаем переменную кнопки
elem223.addEventListener('click', function() {//навешаем событие клика на кнопку
	setTimeout(function() {//создаем временную задержку методом setTimeout, первым параметром использует функцию, вторым продолжительность паузы
		alert('!');
	}, 3000);
});

//______________________________
//256 Создание и вставка элементов
//Для размещения нового элемента на странице применяется метод appendChild. Этот метод следует применять к тому элементу, в который мы хотим поместить наш элемент. 
//А параметром метода следует передавать наш новый элемент, созданный ранее через createElement.
//Метод document.createElement в HTML-документах создаёт элемент c тем тегом, что указан в аргументе
//Синтаксис - var element = document.createElement(tagName, [options]);
//Метод Node.appendChild - добавляет узел в конец списка дочерних элементов указанного родительского узла. 
//Синтаксис - var child = element.appendChild(child);
let elem224_1 = document.querySelector('#elem224_1');//сзодаем кнопку
let parent224 = document.querySelector('#parent224');//создаем список

elem224_1.addEventListener('click', function() {//создаем событие клика на кнопке
let p224 = document.createElement('p');//создаем анонимный тег параграфа
p224.innerHTML = '!';//тегу параграфа передаем значение
parent224.appendChild(p224);//размещаем на странице новый тег
})

//______________________________
//257 Привязывание событий при вставке элементов
//Метод document.createElement в HTML-документах создаёт элемент c тем тегом, что указан в аргументе
//Синтаксис - var element = document.createElement(tagName, [options]);
//Метод Node.appendChild - добавляет узел в конец списка дочерних элементов указанного родительского узла. 
//Синтаксис - var child = element.appendChild(child);
let parent225 = document.querySelector('#parent225');//в переменную записываем div родителя
let p225 = document.createElement('p');//в переменную записываем созданный тег элемент
p225.innerHTML = '!';//тегу р из переменной присваиваем значение
p225.addEventListener('click', function() {//привязываем событие клика
	alert(this.innerHTML); // по клику выведем текст значения абзаца  
});
parent225.appendChild(p225);//позиционируем тег p

//______________________________
//258 Создание элементов в цикле
//Метод document.createElement в HTML-документах создаёт элемент c тем тегом, что указан в аргументе
//Синтаксис - var element = document.createElement(tagName, [options]);
//Метод Node.appendChild - добавляет узел в конец списка дочерних элементов указанного родительского узла. 
//Синтаксис - var child = element.appendChild(child);
let parent226 = document.querySelector('#parent226');//в переменную записываем div родителя
for (let i = 1; i <= 9; i++) {//создаем цикл от 1 до 9
	let p226 = document.createElement('p');//в переменную записываем созданный тег элемент
	p226.innerHTML = '!';//тегу р из переменной присваиваем значение
	parent226.appendChild(p226);//позиционируем тег p
}

//______________________________
//259 Навешивание обработчиков в цикле
//Метод document.createElement в HTML-документах создаёт элемент c тем тегом, что указан в аргументе
//Синтаксис - var element = document.createElement(tagName, [options]);
//Метод Node.appendChild - добавляет узел в конец списка дочерних элементов указанного родительского узла. 
//Синтаксис - var child = element.appendChild(child);
let parent227 = document.querySelector('#parent227');//в переменную записываем div родителя
for (let i = 1; i <= 9; i++) {//создаем цикл от 1 до 9
	let p227 = document.createElement('p');//в переменную записываем созданный тег элемент
	p227.innerHTML = '!';//тегу р из переменной присваиваем значение
	p227.addEventListener('click', function() {//привязываем событие клика
		alert(this.innerHTML);//вывод на экран значений создаваймых тегов
	});
	parent227.appendChild(p227);//позиционируем тег p
}
 
//______________________________
//260 Создание элементов из массива
//Метод document.createElement в HTML-документах создаёт элемент c тем тегом, что указан в аргументе
//Синтаксис - var element = document.createElement(tagName, [options]);
//Метод Node.appendChild - добавляет узел в конец списка дочерних элементов указанного родительского узла. 
//Синтаксис - var child = element.appendChild(child);
 let arr228 = [1, 2, 3, 4, 5];//объявляем массив
 let parent228 = document.querySelector('#parent228');//в переменную записываем div родителя
for (let elem of arr228) {//перебираем массив циклом 
	let p228 = document.createElement('p');//создаем методом createElement новый тег параграфа и передаем его в переменную
	p228.innerHTML = elem;//значение переменной (тега параграфа) равен элементу массива
	parent228.appendChild(p228);//позиционируем зозданный тег параграфа
}

//______________________________
//261_1 Создание элементов из массива
//Метод document.createElement в HTML-документах создаёт элемент c тем тегом, что указан в аргументе
//Синтаксис - var element = document.createElement(tagName, [options]);
//Метод Node.appendChild - добавляет узел в конец списка дочерних элементов указанного родительского узла. 
//Синтаксис - var child = element.appendChild(child);
 let a229_1 = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]//объявляем массив
 let parent229_1 = document.querySelector('#parent229_1')//присваиваем переменной значение списка ul
 for (let elems229_1 of a229_1)// цикл перебора массива
 {
 let li229_1 = document.createElement ('li')//создаем тег li
 li229_1.innerHTML = elems229_1//присваиваем созданному тегу li значение из цикла (значение из массива)
 parent229_1.appendChild(li229_1);//позиционирование созданного тега
 }
 
//______________________________
//261_4 Создание элементов из массива
//Метод document.createElement в HTML-документах создаёт элемент c тем тегом, что указан в аргументе
//Синтаксис - var element = document.createElement(tagName, [options]);
//Метод Node.appendChild - добавляет узел в конец списка дочерних элементов указанного родительского узла. 
//Синтаксис - var child = element.appendChild(child);
 let a229_4 = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]//объявляем массив
 let parent229_4 = document.querySelector('#parent229_4')//присваиваем переменной значение списка ul
 for (let elems229_4 of a229_4)// цикл перебора массива
 {
 let li229_4 = document.createElement ('li')//создаем тег li
 li229_4.innerHTML = elems229_4 //присваиваем созданному тегу li значение из цикла (значение из массива)
 li229_4.addEventListener('click', func229_4)//навешиваем событие клика на созданную переменную с тегом li -список
 function func229_4()//объявляем функцию исполняемую при событие клика
{
this.innerHTML = this.innerHTML + '!';//записываем в значение созданного тега значение с !
li229_4.removeEventListener('click', func229_4);//блокировка события навешанного на созданный тег
//parent229_4.removeChild (li229_4)//удаление созданного тега с помощью метода removeChild 
};
parent229_4.appendChild(li229_4);//позиционирование созданного тега
}

//______________________________
//262 Создание HTML таблиц
let table230 = document.querySelector('#table230');//создаем переменную в которую передаем значение тега таблицы
for (let i = 1; i < 4; i++) {//создаем цикл for для строк
	let tr = document.createElement('tr');//создаем узел тег tr с помощью метода createElement и передаем в переменную
	for (let j = 1; j < 4; j++) {//создаем цикл for для столбцов
		let td = document.createElement('td'); //создаем узел тег td с помощью метода createElement и передаем в переменную
		td.innerHTML = i+'/'+j //заполняем значение созданного тега td 
		tr.appendChild(td);//позиционируем тег td, говорим что тег td создается в теге tr
	}
	table230.appendChild(tr);//позиционируем строки, что они в теге таблицы
}

//______________________________
//263 Последовательное заполнение HTML таблиц
let table231 = document.querySelector('#table231');//создаем переменную в которую передаем значение тега таблицы
let k231 = 0; // начальное значение счетчика
for (let i = 0; i < 10; i++) {//создаем цикл for для строк
	let tr = document.createElement('tr');//создаем узел тег tr с помощью метода createElement и передаем в переменную
	for (let j = 0; j < 10; j++) {//создаем цикл for для столбцов
		let td = document.createElement('td');//создаем узел тег td с помощью метода createElement и передаем в переменную
		td.innerHTML = k231; // записываем счетчик в ячейку (столбец)
		k231++; // увеличиваем счетчик
		tr.appendChild(td);//позиционируем тег td, говорим что тег td создается в теге tr
	}
	table231.appendChild(tr);//позиционируем строки, что они в теге таблицы
}

//______________________________
//264 Создание HTML таблицы из массива
let arr232 = [[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12]]; //создаем многомерный массив
let tabie232 = document.querySelector ('#table232') //передаем в переменную значение тега таблицы
for (let subarr232 of arr232)//создаем цикл for of чтобы вытащить подмассивы
{
let tr = document.createElement ('tr')//создаем узел тег tr с помощью метода createElement и передаем в переменную
	for (let elems232 of subarr232)//создаем цикл for of чтобы вычленить элементы в подмассивах
	{
	let td = document.createElement ('td')//создаем узел тег td с помощью метода createElement и передаем в переменную
	td.innerHTML = elems232 // записываем в значение ячейки (столбеца) значение элементов подмассива
	tr.appendChild(td);//позиционируем тег td, говорим что тег td создается в теге tr
	}
table232.appendChild(tr)//позиционируем строки, что они в теге таблицы
}

//______________________________
//265 Создание HTML таблицы из массива объектов
let users233 = [// создаем многомерный массив из объектов
	{
		name: 'name1',
		surname: 'surname1',
		patronymic: 'patronymic1'
	},
	{
		name: 'name2',
		surname: 'surname2',
		patronymic: 'patronymic2'
	},
	{
		name: 'name3',
		surname: 'surname3',
		patronymic: 'patronymic3'
	},
];
let table233 = document.getElementById('table233');//присваиваем переменной значение тега таблицы

for (let user233 of users233) {//цикл for of  который перебирает многомерный массив
	let tr = document.createElement('tr');//создаем тег tr и передаем в переменную
	
	let td1 = document.createElement('td');//создаем тег td и передаем в переменную
	td1.innerHTML = user233.name;//  тегe td передаем значение из одного элемента объекта
	tr.appendChild(td1);//позиционируем созданный тег td в строке tr
	
	let td2 = document.createElement('td');//создаем тег td и передаем в переменную
	td2.innerHTML = user233.surname;//  тегe td передаем значение из одного элемента объекта
	tr.appendChild(td2);//позиционируем созданный тег td в строке tr
	
	let td3 = document.createElement('td');//создаем тег td и передаем в переменную
	td3.innerHTML = user233.patronymic;//  тегe td передаем значение из одного элемента объекта
	tr.appendChild(td3);//позиционируем созданный тег td в строке tr
	
	table233.appendChild(tr);//позиционируем строку tr в теге таблицы
}

//______________________________
//266 Добавление рядов и колонок в HTML таблицу
//Добавление рядов не составляет труда: нужно создать tr,
//а затем запустить цикл, который добавит нужное количество ячеек в этот ряд
let table234 = document.querySelector('#table234');//присваиваем переменной значение тега таблицы
let tr = document.createElement('tr');//создаем тег tr и передаем в переменную
for (let i = 1; i <= 3; i++) { //создаем цикл
	let td = document.createElement('td');//создаем тег td и передаем в переменную
	td.innerHTML = '0' //задаем значение созданного тега td 
	tr.appendChild(td);// позиционируем созданный тег td в строке таблицы tr
}
table234.appendChild(tr); // позиционируем строку tr в теге таблицы
//Добавление колонок - нужно запустить цикл, который переберет все ряды таблицы и в 
//каждый ряд добавит новую ячейку
let trs234 = document.querySelectorAll('#table234 tr');//находим все tr теги (строки)
//таблицы и передаем массив в переменную
for (let tr of trs234) {//циклом перебираем массив
	let td = document.createElement('td');//создаем тег столбца td
	td.innerHTML = '/'// записываем в столбец значение
	tr.appendChild(td);//позиционируем столбец td в tr  строке
}


//______________________________
//267 Изменение ячеек HTML таблицы
let tds235 = document.querySelectorAll('#table235 td');//находим все td таблицы и передаем массив в переменную
for (let td of tds235) {//перебираем массив
	td.innerHTML = '!';//задаем новое значение ячейкам
}

 //______________________________
//268 Порядковый номер ячейки таблицы
let tds236 = document.querySelectorAll('#table236 td');//получаем все теги td в таблице table236 
for (let i = 0; i < tds236.length; i++) {//запускаем цикл for, где максимальное значение равна значению длинны массива 
	tds236[i].innerHTML = i + 1;//в значение тегов td записываем счетчик 
}

 //______________________________
//269 Номер колонки и ряда таблицы
let trs237 = document.querySelectorAll('#table237 tr');//записываем в массив строки из таблицы

for (let i = 0; i < trs237.length; i++) {//перебираем строки таблицы
	let tr237 = trs237[i];//каждую строку передаем в переменную
	let tds237 = tr237.querySelectorAll('td');//из каждой строки получем массив с столбцами ( ячейками)
	
	for (let j = 0; j < tds237.length; j++) {//массив перебираем
		let td237 = tds237[j];//каждый элемент столбцов передаем в переменную
		td237.innerHTML = i + '.' + j;//задаем значение столбцов
	}
}

 //______________________________
//270 Порядковый номер ячейки по клику
let tds238 = document.querySelectorAll('#table238 td');//находим все ячейки (столбцы) в таблице
for (let i = 0; i < tds238.length; i++) {//создаем счетчик, где макс значение длинна псевдомассива элементов 
	tds238[i].addEventListener('click', function() {//при клике на элемент с переданным порядком
		this.innerHTML = i;//изменяем значение
	});
}

 //______________________________
//271 Порядковый номер клика в ячейке
let tds239 = document.querySelectorAll('#table239 td');//записываем в переменную псевдомассив с ячейками (столбцами)
let i239 = 1;//объявляем счетчик
for (let td239 of tds239) {//перебираем по порядку
	td239.addEventListener('click', function() {//при клике на элемент навешиваем событие и исполняем функцию
		this.innerHTML = i239;//в значение тега по которому был клик записываем значение счетчика
		i239++;//счетчик увеличиваем на 1
	});
}

/*Чередование 1 и 2
let tds = document.querySelectorAll('#table td');//записываем в переменную псевдомассив с ячейками (столбцами)
let i = 1;//объявляем счетчик
for (let td of tds) {//перебираем по порядку
	td.addEventListener('click', function() {//при клике на элемент навешиваем событие и исполняем функцию
		this.innerHTML = i;//в значение тега по которому был клик записываем значение счетчика
		
		if (i == 1) { //если счетчик = 1 то значение счетчика 2
			i = 2;
		} else {//в противном случае 1
			i = 1;
		}
	});
}
*/

 //______________________________
//272 Удаление элементов
let parent240 = document.querySelector('#parent240');//задаем родительский див в переменную
let elem240_1   = document.querySelector('#elem240_1');//задаем тег параграфа в переменную
let elem240_2   = document.querySelector('#elem240_2');//задаем тег параграфа в переменную
let elem240_3   = document.querySelector('#elem240_3');//задаем тег параграфа в переменную
let elem240   = document.querySelector('#elem240');//задаем значение кнопки в переменную
elem240.addEventListener('click', function() {//когда по элементу кнопки будет событие клика то исполняем функцию
parent240.removeChild(elem240_1);//удалим первый параграф методом removeChild (принимает родительский тег а в параметрах (тег который удаляем)
elem240_2.parentElement.removeChild(elem240_2);//метод removeChild (принимает родительский тег а в параметрах (тег который удаляем),
// вместо родительского тега можно использовать свойство parentElement к подчиненному тегу (определить - результат выдаст тег родителя)
elem240_3.remove();//метод remove() удаляет элемент к которому применяется метод
})

 //______________________________
//273 Самоудаление элементов
let parent241 = document.querySelector('#parent241');//задаем родительский див в переменную
let elems241  = document.querySelectorAll('#parent241 p');//записываем в псевдамассив все теги параграфа

for (let elem241 of elems241) {//перебираем теги
	elem241.addEventListener('click', function() {//когда по элементу будет событие клика то исполняем функцию
		parent241.removeChild(this);//к родительскому диву применим метод removeChild, который удалит тег в параметрах
	});
}

 //______________________________
//274 Самоудаление новых элементов

let elem242   = document.querySelector('#elem242')//объявляем переменную куда записываем инпут кнопки
elem242.addEventListener('click', function() {//передаем переменной событие клика 	
let parent242 = document.querySelector('#parent242');//объявляем родителя див, передаем в переменную
for (let i = 1; i <= 9; i++) {//создаем счетсик
	let p242 = document.createElement('p');//создаем тег параграфа - р, передаем в переменнуюб
	p242.innerHTML = i;//тегу параграфа передаем значение из порядка цикла
	p242.addEventListener('click', function() {//при клике на тег параграфа исполняется событик клика
		parent242.removeChild(this);//удаление параграфа при помощи метода removeChild, где параметром 
		//будет сам тег которого удаляем, а применяем метод к тегу родителю
	});
	parent242.appendChild(p242);//позиционируем созданный тег параграфа 
}
})

 //______________________________
//275 Ссылка на удаление элемента
let elem243   = document.querySelector('#elem243');//объявляем переменную куда записываем тег параграфа
let remove243 = document.querySelector('#remove243');//объявляем переменную куда записываем тег ссылки
remove243.addEventListener('click', function(event) {//при клиек на ссылку вызываем объект event
	elem243.parentElement.removeChild(elem243);//удаляем параграф при помощи метода removeChild,
//	в параметрах переменная с параграфом , а применяется к родительскому тегу полученному при помощи метода parentElement
		event.preventDefault(); // отменяем переход по ссылке
});

 //______________________________
//276 Создание ссылок для удаление элементов

let elems244 = document.querySelectorAll('#parent244 p');//объявляем переменную которой передаем все теги параграфов из дива parent244
for (let elem244 of elems244) {//перебираем теги параграфов из массива 
	let remove244 = document.createElement('a');//создаем тег ссылки
	remove244.href = '';//в переменную ссылки вписываем значение ссылки (куда)
	remove244.innerHTML = 'remove';//в название вписываем innerHTML
	elem244.appendChild(remove244);//позиционируем тег ссылки в пеге параграфа
	remove244.addEventListener('click', function(event) {//при клике на ссылку вызываем событие клика с объявлением объекта event
		elem244.parentElement.removeChild(elem244);//удаляем параграф при помощи метода removeChild,
//	в параметрах переменная с параграфом , а применяется к родительскому тегу полученному при помощи метода parentElement
		
		event.preventDefault();// отменяем переход по ссылке
	});
}

 //______________________________
//277 Вставка элементов в начало или в конец. Методы append, prepend и insertBefore
//Метод append позволяет вставить в конец какого-либо элемента другой элемент. Параметром метод принимает элемент, 
//как правило созданный через createElement, либо строку. Можно добавить сразу несколько элементов или строк, 
//перечислив их через запятую. Синтаксис - родитель.append(элемент или строка)

let parent245 = document.querySelector('#parent245');//создаем переменную которой передаем значение от области див
let p245_11 = document.createElement('p');//создаем новый тег абзаца
p245_11.innerHTML = 'a';//тегу абзаца передаем значение
let p245_12 = document.createElement('p');//создаем новый тег абзаца
p245_12.innerHTML = 'b';//тегу абзаца передаем значение
parent245.append(p245_11, p245_12, 'текст и строки');//позиционируем новый тег методом append
	for (let i = 1; i <= 5; i++) {//объявляем счетчик
		let  p245_13 = document.createElement('p');//создаем новый тег абзаца
		p245_13.innerHTML = i;//тегу абзаца передаем значение
		parent245.append(p245_13);//позиционируем новый тег методом append
	}
//Метод prepend позволяет вставить в начало какого-либо элемента другой элемент. 
//Параметром метод принимает элемент, как правило созданный через createElement, либо строку. 
//Можно добавить сразу несколько элементов или строк, перечислив их через запятую.	
//Cинтаксис - родитель.prepend(элемент или строка)

let p245_14 = document.createElement('p');//создаем новый тег абзаца
p245_14.innerHTML = 'a';//тегу абзаца передаем значение
let p245_15 = document.createElement('p');//создаем новый тег абзаца
p245_15.innerHTML = 'b';//тегу абзаца передаем значение
	parent245.prepend( 'текст и строки', p245_15, p245_14);//позиционируем новый тег методом prepend
	for (let i = 1; i <= 5; i++) {//объявляем счетчик
		let  p245_13 = document.createElement('p');//создаем новый тег абзаца
		p245_13.innerHTML = i;//тегу абзаца передаем значение
		parent245.prepend(p245_13);//позиционируем новый тег методом prepend
	}
//Метод insertBefore позволяет вставить элемент перед другим элементом. 
//Чаще всего используется после создания элемента с помощью createElement.
// Метод применяется к родителю того элемента, перед которым произойдет вставка.
// Синтаксис - родитель.insertBefore(элемент, перед кем вставить)
	let before245 = document.querySelector('#before245');//создаем переменную которой передаем значение от абзаца
	let p245 = document.createElement('p');//создаем новый тег абзаца
p245.innerHTML = 'середина (вставка абзаца в указанное место)';//тегу абзаца передаем значение
parent245.insertBefore(p245, before245);//позиционируем новый тег методом insertBefore

 //______________________________
//278 Смежная вставка элементов. Методы insertAdjacentElement и insertAdjacentHTML
//Метод insertAdjacentElement позволяет вставить элемент в любое место страницы. 
//Чаще всего используется после создания элемента с помощью createElement.
//Код вставляется относительно опорного элемента.
// Можно сделать вставку перед опорным элементом (способ вставки beforeBegin),
// после него (способ вставки afterEnd), а также в начало (способ вставки afterBegin) или в конец 
//(способ вставки beforeEnd) опорного элемента. 
//Синтаксис - Опорный элемент.insertAdjacentElement(способ вставки, код для вставки)

let p246 = document.createElement('p');//создаем тег параграфа а значение передаем переменной
p246.innerHTML = '8_8';//значение тега параграфа задаем 
let p246_2 = document.createElement('p');//создаем тег параграфа а значение передаем переменной
p246_2.innerHTML = '9_9';//значение тега параграфа задаем 
let target246 = document.querySelector('#target246');//записываем в переменную свойство тега параграфа - target246 
target246.insertAdjacentElement('beforeBegin', p246);//вставляем новый тег относительно опорного элемента
target246.insertAdjacentHTML('beforeBegin', '<p>88</p>');//вставляем новый тег относительно опорного элемента
target246.insertAdjacentElement('afterEnd', p246_2);//вставляем новый тег относительно опорного элемента
target246.insertAdjacentHTML('afterEnd', '<p>99</p>');//вставляем новый тег относительно опорного элемента

// ______________________________
//279 Клонирование элементов
//Клонировать элемент можно с помощью метода cloneNode. В этот метод нужно передавать параметром true либо false. 
//Если передан true, то элемент клонируется полностью, вместе со всем атрибутами и дочерними элементами, 
//а если false - только сам элемент.
let parent247 = document.querySelector('#parent247');//получение в переменную области id
let elem247 = parent247.querySelector('.elem247');//получение в переменную области по классу 
let clone247 = elem247.cloneNode(true);//копируем класс методом cloneNode и передаем переменную
parent247.appendChild(clone247);//позиционируем класс в родителе parent247 методом appendChild

// ______________________________
//280 Проверка элементов
//Метод matches позволяет проверить, удовлетворяет ли элемент указанному CSS селектору.
//синтаксис -элемент.matches('селектор');
let elem248 = document.querySelector('#elem248');//записываем тег абзаца в переменную 
console.log(elem248.matches('p.www248'));//проверяем находится ли css стиль - класс в абзаце и выводим в консль true если да

//Метод contains позволяет проверить, содержит ли один элемент внутри себя другой. 
//Параметром метода передается элемент, который будет проверяться на то, что он находится внутри элемента, к которому применился метод.
//синтаксис - родитель.contains(элемент)
let parent248_2 = document.querySelector('#parent248_2');//передаем в переменную тег абзаца
let child248_2 = document.querySelector('#child248_2');//передаем в переменную тег параграфа
let contains248_2 = parent248_2.contains(child248_2);//проверяем есть ли в абзаце параграф
console.log(contains248_2);//выведет true если есть один в другом

// ______________________________
//281 Редактирование отдельного элемента
//Редактировать тексты элементов с помощью полей ввода. 
let elem249 = document.querySelector('#elem249');//передаем в переменную тег абзаца
elem249.addEventListener('click', function() {//при клике на абзац вызаваем событие клика который исполняет функцию
	let input249 = document.createElement('input');//создаем инпут - область ввода, которую передаем в переменную
	input249.value = elem249.innerHTML;//переменной области ввода передаем значение
	input249.addEventListener('blur', function() {//при потере фокуса от области ввода 
		elem249.innerHTML = this.value;//записываем новое значение области вводща
		this.parentElement.removeChild(this); // удалим инпут
	});
	elem249.parentElement.appendChild(input249);//позиционируем созданный инпут 
});

// ______________________________
//282 Прячем текст при редактировании элемента

let elem250 = document.querySelector('#elem250');//в переменную передаем тег абзаца
elem250.addEventListener('click', function func() {//привязываем к переменной событие клика которое передает функцию
	let input250 = document.createElement('input');//переменной передаем создаваемый элемент
	input250.value = elem250.innerHTML;//значение соданного элемента равно значению абзаца
	elem250.innerHTML = '';//значение абзаца стираем
	elem250.appendChild(input250);//позиционируем новый элемент относительно родителя
	input250.addEventListener('blur', function() {//привязываем к созданному элементу событие потери фокуса
		elem250.innerHTML = this.value;//при потере фокуса тегу абзаца передаем значение созданного элемента области
		elem250.addEventListener('click', func); // снова навязываем событие  повесим событие
	});
	elem250.removeEventListener('click', func);//прекращение кликов
	
});

// ______________________________
//283 Редактирование в группе элементов

let elems251 = document.querySelectorAll('#parent251 p');//получение тегов с p
console.log (elems251)
for (let elem251 of elems251) {//перебор тегов
	elem251.addEventListener('click', function func251() {//привязываем к переменной событие клика которое передает функцию
		let input251 = document.createElement('input');//переменной передаем создаваемый элемент
		input251.value = elem251.innerHTML;//значение соданного элемента равно значению абзаца
		
		elem251.innerHTML = '';//значение абзаца стираем
		elem251.appendChild(input251);//позиционируем новый элемент относительно родителя
		
		input251.addEventListener('blur', function() {//привязываем к созданному элементу событие потери фокуса
			elem251.innerHTML = this.value;//при потере фокуса тегу абзаца передаем значение созданного элемента области
			elem251.addEventListener('click', func251);// снова навязываем событие  повесим событие
		});
elem251.removeEventListener('click', func251);//прекращение кликов
	});
}

// ______________________________
//284 Одновременное редактирование и удаление элементов
let parent252 = document.querySelector ('#parent252')//переменной передаем значение тега див 
let elems252 = document.querySelectorAll('#parent252 span');//получение тегов span записав в переменную
console.log (elems252)//выведем теги span в консоль
for (let elem252 of elems252) {//перебор тегов span
elem252.addEventListener('click', function func252() {//начешиваем событие клика на каждый беребираемый тег span
let input252 = document.createElement('input');//переменной передаем создаваемый элемент инпут
input252.value = elem252.innerHTML;//значение соданного элемента инпута равно значению абзаца
elem252.innerHTML = '';//значение абзаца стираем
		elem252.appendChild(input252);//позиционируем новый элемент относительно родителя
	input252.addEventListener('blur', function() {//привязываем к созданному элементу событие потери фокуса
		elem252.innerHTML = this.value;//при потере фокуса тегу абзаца передаем значение созданного элемента области
			})
			elem252.removeEventListener('click', func252);//прекращение кликов
			});
}
let elems252_2 = document.querySelectorAll('#parent252 a');//получение тегов с а - тег ссылки
console.log (elems252_2)//вывод в консоль
for (let elem252_2 of elems252_2) {//перебор тегов
elem252_2.addEventListener('click', function func252_2(event) {//навешиваем на теги ссылки событие клика с объектом event
parent252.removeChild(elem252_2.parentElement)//удаляем тег span,полученым свойством parentElement
event.preventDefault();// отменяем переход по ссылке
})
}

// ______________________________
//285 Стилизация элементов
let parent253 = document.querySelector ('#parent253')//переменной передаем значение тега див 
let elems253_2 = document.querySelectorAll('#parent253 span');//получение тегов span записав в переменную
for (let elem253_2 of elems253_2) {//перебор тегов span
let remove253 = document.createElement('a');//создаем в каждом теге span тег ссылки и передаем в переменную
remove253.href = '';//в переменную ссылки вписываем значение ссылки (куда)
remove253.innerHTML = 'remove';//в название вписываем innerHTML
elem253_2.parentElement.appendChild(remove253);//позиционируем тег ссылки, получив родителя свойством parentElement
remove253.addEventListener('click', function(event) {//по клику на ссылку
elem253_2.className = 'stile253'//назначам класс стиля 'stile253'
event.preventDefault();// отменяем переход по ссылке
})
}

// ______________________________
//286 Кнопки для скрытия и показа элемента
let elem254 = document.querySelector('#elem254');//переменной передаем тег парагафа
let show254 = document.querySelector('#show254');//переменной передаем тег кнопки
let hide254 = document.querySelector('#hide254');//переменной передаем тег кнопки
hide254.addEventListener('click', function() {//навешиваем событие клика на кнопку 
	elem254.classList.add('hidden254');//при клике добавляем в классы параграфа новый css стиль клас
});
show254.addEventListener('click', function() {//навешиваем событие клика на кнопку 
	elem254.classList.remove('hidden254');//при клике удаляем  класс в класслисте параграфа - css стиль клас
});

// ______________________________
//287 Много элементов с кнопками показа
let buttons255_1 = document.querySelectorAll('#parent255_1 button');//передаем в переменную массив из тегов button
for (let button255_1 of buttons255_1) {//перебираем псевдомасив
	button255_1.addEventListener('click', function() {//навешиваем событие клика на каждый элемент массива
//	- тег batton
		let elem255_1 = document.querySelector('#' + this.dataset.elem);//передаем в переменную тег параграфа, 
		//id которого получен с помощью пользовательского атрибута data-
		console.log (elem255_1)//вывод переменоой параграфа в консоль дляф проверки
	elem255_1.classList.toggle('hidden255');//переменной параграфа на которой был клик с помощью объекта classList
//	и метода toggle добавляем новый стиль
	});
}

let buttons255_2 = document.querySelectorAll('#parent255_2 button');//передаем в переменную массив из тегов button
let elems255_2 = document.querySelectorAll('#parent255_2 p');//передаем в переменную массив из тегов p - параграфы
for (let i = 0; i < buttons255_2.length; i++) {//создаем цикл for, где макс значение - длинна массива тегов batton
	buttons255_2[i].addEventListener('click', function() {//каждому тегу из массива навешиваем событие клика 
		elems255_2[i].classList.toggle('hidden255');//каждому элементу массива из тегов p навешиваем стиль с помощью объекта classList
//	и метода togglе
	});
}

let buttons255_3 = document.querySelectorAll('#parent255_3 button');//передаем в переменную массив из тегов button
for (let button255_3 of buttons255_3) {//перебираем псевдомасив
	button255_3.addEventListener('click', function() {//навешиваем событие клика на каждый элемент массива
//	- тег batton
		this.previousElementSibling.classList.toggle('hidden255');//у каждого элемента массива находим соседний тег у тега batton - тег p 
		//и навешиваем стиль с помощью объекта classList и метода togglе
	});
}

// ______________________________
//288 Активация элементов
let tds256 = document.querySelectorAll('#table256 td');//получаем псевдомассив таблицы (столбцов) - ячейки
for (let td of tds256) {//перебираем массив столбцов циклом for
	td.addEventListener('click', function() {//каждому столбцу навешиваем событие клика который2 исполняет функцию
		this.classList.add('active256');//ключевого слова this указывает на элемент по которому прошло событие, 
//к нему добавляем объект classList и метода add, который добавляет класс 'active256' в массив  классов 
	});
}

// ______________________________
//289 Чередование стилей активации
let tds257 = document.querySelectorAll('#table257 td');//получаем псевдомассив таблицы (столбцов) - ячейки
let color = 'color257_1';//создаем строку 'color257_1'
for (let td of tds257) {//перебираем массив столбцов (ячеек) 
	td.addEventListener('click', function() {// каждой ячейке привязываем событие клика
		if (color == 'color257_1') {//условие к строке color 
			color = 'color257_2'
		} else {
			color = 'color257_1'
		}
		
		this.classList.add(color);//каждой ячейке по которой был клик(к которой указывает объект this) добавляем класлист из строкаи color
	});
}
// ______________________________
//289_1 Чередование стилей активации

let tds257_1 = document.querySelectorAll('#table257_1 td');//получение псевдомассива из ячеек таблицы 
let i257 = 0;//объявление переменной 
let colors257 = ['color257_1', 'color257_2', 'color257_3'];//объявление массива из строк

for (let td of tds257_1) {//перебор массива ячеек циклом for of
	td.addEventListener('click', function() {//навешивание на перебираемые ячейки событие клика
		this.classList.add(colors257[i257]);//в объект this, куда передаем элемент по которому был клик применяем объект класлиск
		//в параметр которого передаем элемент массива задаваемый переменной
		i257++;//счетчик
		if (i257 == colors257.length) {//условие которое сбрасывает счетчик при достижении максимальной длинны массива
			i257 = 0;
		}
	});
}

// ______________________________
//290 Активация ограниченного количества элементов
let tds258 = document.querySelectorAll('#table258 td');//получение псевдомассива из ячеек таблицы 
for (let td of tds258) {//перебор массива ячеек циклом for of
	td.addEventListener('click', function() {//навешивание на перебираемые ячейки событие клика
		let activeTds = document.querySelectorAll('#table258 td.active258');//находим массив из ячеек у которых есть класс active258, передаем в переменную
		console.log (activeTds.length)//выводим в консоль длинну массива
		if (activeTds.length < 3) {//условие если длинна массива меньше 3 то 
			this.classList.add('active258');//вписываем класс active258 в класслист
		}
	});
}

// ______________________________
//291_1 Практика на изменение элементо
let elem259 = document.querySelector('#elem259_1');//передаем в переменную значение тега ul
let elems259_1 = document.querySelectorAll('#elem259_1 li');///передаем в переменную значение тегов li

for (let elem259_1 of elems259_1) {//перебор тегов li
elem259_1.addEventListener('click', function func259_1() {//передаем на каждый из тегов li событие клика
let input259_1 = document.createElement('input');//содаем новый тег - область ввода при клиек
	input259_1.value = elem259_1.innerHTML;//значение тега области ввода равна значению элемента li по которому был клик
	elem259_1.innerHTML = '';//тегу списка значение удаляем (пустое значение)
	elem259_1.appendChild(input259_1);//позиционируем новый элемент - область ввода в теге списка по которому был клик
		
input259_1.addEventListener('blur', function() {//привязываем к списку li из цикла событие потери фокуса
elem259_1.innerHTML = this.value;//при потери фокуса значение списка равно значению из области ввода
elem259_1.addEventListener('click', func259_1);// присваиваем повторно событие клика тегу списка li
})
elem259_1.removeEventListener('click', func259_1);//прекращение события кликов по списку li
	
let show259_3 = document.querySelector('#show259_3');//переменной передаем тег кнопки "показывать"
let hide259_3 = document.querySelector('#hide259_3');//переменной передаем тег кнопки "спрятать"
let create259_3 = document.querySelector('#create259_3');//переменной передаем тег кнопки "создать" 
hide259_3.addEventListener('click', function() {//навешиваем событие клика на кнопку "спрятать"
elem259_1.classList.add('hidden259_3');//при клике добавляем в список классов параграфа - тегов списка  новый css стиль класс (не отображать)
});
show259_3.addEventListener('click', function() {//навешиваем событие клика на кнопку "показывать"
elem259_1.classList.remove('hidden259_3');//при выполнении функции клика удаляет класс 'hidden259_3'
});
});
}
create259_3.addEventListener('click', function() {//навешиваем событие клика на кнопку "создать"
let input259 = document.createElement('li');//добавляем новый тег списка  li при исполнении функции клика
elem259.appendChild(input259);//позиционируем новый элемент - в теге ul
input259.innerHTML = 'item';// новому тегу li передаем значение 'item'
input259.addEventListener('click', function func259_2() {//навешиваем событие клика на новый тег li 
let input259_2 = document.createElement('input')//создаем новый тег область ввода при клике на новый li 
input259_2.value = input259.innerHTML;//значение области ввода равна значению созданного тега списка li 
input259.innerHTML = '';//значение созданного тега списка стираем
input259.appendChild(input259_2);//позиционируем новую область ввода в соданном теге списка
input259_2.addEventListener('blur', function() {//при потере фокуса на области ввода 
input259.innerHTML = this.value;//значение созданного тега списка равна значению области ввода 
input259.addEventListener('click', func259_2);//при клике на созданный тег списка li исполняем снова функцию func259_2()
})
input259.removeEventListener('click', func259_2);//прекращение кликов по созданному тегу списка li 
hide259_3.addEventListener('click', function() {//навешиваем событие клика на кнопку "спрятать"
input259.classList.add('hidden259_3');//при клике добавляем в классы созданных спискоф параграфа новый css стиль класс (не отображать)
});
show259_3.addEventListener('click', function() {//навешиваем событие клика на кнопку "показывать"
input259.classList.remove('hidden259_3');//при выполнении функции клика удаляет класс 'hidden259_3'
});
});
});

// ______________________________
//292 Поиск ячеек таблицы с помощью атрибута data
let col260 = 3;//объявляем переиенную 
let tds260 = document.querySelectorAll('#table260 td[data-col="' + col260 + '"]');//получаем маасив с ячейками гда теги  
//td[data-col="3"]
for (let td260 of tds260) {//перебираем каждый тег 
	td260.innerHTML = '!';//передаем значение
}
// ______________________________
//293 Добавление номера колонки и ряда в таблицу
let tds261 = document.querySelectorAll('#table261 td');//получаем массив с ячейками
let trs261 = document.querySelectorAll('#table261 tr');//получаем массив столбцов
let i261 = 0//объявляем переменную
let m261 = 1//объявляем переменную
for (let td261 of tds261) {//перебираем массив ячеек циклом for of
++i261//добавляем счетчик
if (i261 == 4)//условие если значение равно 4
{
i261 = 1 //то переменная i261 равна 1
}
td261.setAttribute('data-col', i261)//присваиваем атрнибут 'data-col' которолй передаем значение i261
console.log (td261.dataset.col + 'строка')//выводим в консоль значение (сообщение) значение 'data-col' и 'строка'
}
for (let tr261 of trs261) {//перебираем массив столбцов 
let elems261 = tr261.children;//записываем в массив все подчиненные теги (детей) тега столбца tr261
for (let elem261 of elems261) {//перебираем каждый столбец (элементы из массива тегов из столбца)
elem261.setAttribute('data-row', m261)//присваиваем атрнибут'data-row'которолй передаем значение m261
console.log (elem261.dataset.row + 'ряд')//выводим в консоль сообщение (сообщение) значение  'data-row' и 'ряд'
}
++m261//добавляем счетчик
}

// ______________________________
//294 Поиск ячеек таблицы через селектор CSS
//Псевдокласс :nth-child используется для добавления стиля к элементам на основе нумерации в дереве элементов.
/* <style>
   table { 
    width: 100%; // Ширина таблицы 
    border-spacing: 0; // Расстояние между ячейками 
   }
   tr:nth-child(2n) {
    background: #f0f0f0; // Цвет фона 
   } 
   tr:nth-child(1) {
    background: #666; // Цвет фона 
    color: #fff; // Цвет текста 
   } 
   </style>
*/
//Помимо этого с помощью него можно вести поиск элементов через селектор CSS

let td262 = document.querySelector('#table262 tr:nth-child(3) td:nth-child(2)');//находит 2 элемент 3 строки таблицы
console.log ( td262.innerHTML)//выведит 32 - элемент, значение ячейки таблицы

let tds262 = document.querySelectorAll('#table262 td:nth-child(2)');//находит 2 элементы таблицы
for (let td of tds262) {//циклом перебираем массив 
	td.innerHTML = '!';//ячейкам присваиваем значения 
}
let tdsq = document.querySelectorAll('#table262 tr:nth-child(odd) td:nth-child(1)');//находит нечетные элементы таблицы - значение odd

for (let td of tdsq) {//циклом перебираем массив 
	td.innerHTML = '@';//ячейкам присваиваем значения 
}

let tdsw = document.querySelectorAll('#table262 tr:nth-child(even) td:nth-child(1)');//находит четные элементы таблицы - значение even
for (let td of tdsw) {//циклом перебираем массив 
	td.innerHTML = '#';//ячейкам присваиваем значения 
}


// ______________________________
//295 Функции для работы с DOM элементом
//Вспомогательные функции, выполняющие какие-либо операции с DOM
function setText263 (id, text) {//объявляем функцию с параметрами в которых передается id и значение
	let elem263 = document.getElementById(id);//записываем в переменную тег, id которого находится в параметре функции
	elem263.innerHTML = text;//значение элемента переданного в переменную равна параметру из функции
	}
setText263('elem263_1', 'text1');//вызываем функцию с заданными параметрами
setText263('elem263_2', 'text2');//вызываем функцию с заданными параметрами

// ______________________________
//296 Функции для работы с группой DOM элементов
function setText264 (selector, text) {//объявляем функцию - setText264 с параметрами selector, text
	let elems = document.querySelectorAll(selector);//создаем псевдомассив, получаемый из тегов с классом -> selector
	
	for (let elem of elems) {//перебираем все теги у короых класс в параметре selector ->.elem264'
		elem.innerHTML = text;//значение каждого из теребираемых тегов находится в параметре text
	}
}
setText264('.elem264', 'text');//вызываем функцию с заданными параметрами

// ______________________________
//297 Передача коллбэка для работы с DOM
//Функции можно передавать параметрами в другие функции. 
//Такие функции-параметры называются коллбэками (англ. callback). 

forEach297('.elem297', function(elem) {// функция в параметр которой передаем колбэк фукцию
	elem.innerHTML = elem.innerHTML ** 2;//значение элемента параграфа равен квадрату самого себя
		console.log(elem);//вывод в консоль
});
function forEach297(selector, func) {//объявляем функцию у которой 2 параметра
	let elems297 = document.querySelectorAll(selector);//переменной передаем массив элементов по классу, который хранится в переменной
	for (let elem297 of elems297) {//перебираем массив циклом for of 
		func(elem297);//вызываем функцию callback
	}
}

// ______________________________
//298 Передача порядкового номера в коллбэк

forEach298('.elem298', function(elem, index) {// функция в параметр которой передаем колбэк фукцию
	elem.innerHTML = elem.innerHTML ** 2;//значение элемента параграфа равен квадрату самого себя
		console.log(elem);//вывод в консоль
		console.log(index);//вывод в консоль
});
function forEach298(selector, func) {//объявляем функцию у которой 2 параметра
	let elems298 = document.querySelectorAll(selector);//переменной передаем массив элементов по классу, который хранится в переменной
	for (let i = 0; i<elems298.length; i++) {//перебираем массив циклом for
		func(elems298[i],i);//вызываем функцию callback, которому передаем 2 параметра
	}
}

// ______________________________
//299 Передача DOM элемента параметром функции
function setText(elem, text){//объявляем функцию с 2 параметрами
	elem.innerHTML = text;//значение элемента параграфа равен значению из параметра функции
	}
	
let elem299_1 = document.getElementById('elem299_1');//в переменную записываем первый параграф
setText(elem299_1, 'text1');//вызываем функцию с 2 параметрами

let elem299_2 = document.getElementById('elem299_2');//в переменную записываем второй параграф
setText(elem299_2, 'text2');//вызываем функцию с 2 параметрами

// ______________________________
//300 Передача DOM группы элементов параметрами функций
function setText300(elems, text) {//объявляем функцию с 2 параметрами
	for (let elem of elems) {//перебираем массив циклом for of 
		elem.innerHTML = text;//значение элемента параграфа равен значению из параметра функции
	}
}
let elems300 = document.querySelectorAll('.elem300');//в переменную записываем группу элементов параграфа по классу
setText300(elems300, 'text300');//вызываем функцию с 2 параметрами

// ______________________________
//301 Функция для создания HTML таблиц
let div301 = document.querySelector('#elem301');//объявляем div передаваемый в переменную
function createTable301(rows, cols, parent) {//объявляем функцию с 3 параметрами
	let table = document.createElement('table');//создаем новый тег 'table'
	parent.appendChild(table);//parent - переменная (параметр) к которому применяется метод appendChild к table
	for (let i = 1; i <= rows; i++) {//цикл for где макс значение задано переменной-параметром
	let tr = document.createElement('tr')//создаем переменную в которую передаем создаваемый тег 'tr'
		for (let j = 1; j <= cols; j++) {//цикл for где макс значение задано переменной-параметром
		let td = document.createElement('td'); //создаем переменную в которую передаем создаваемый тег 'td'
		td.innerHTML = '1'//значению тега td передаем '1'
		tr.appendChild(td);//позиционируем td
		}
		table.appendChild(tr);//позиционируем tr	
	}
	}
createTable301 (4, 5, div301);//вызываем функцию

// ______________________________
//302 Возврат таблицы из функции
let div302 = document.querySelector('#elem302');//объявляем div передаваемый в переменную
div302.appendChild(createTable302 (4, 5));//позиционируем в div таблицу которая передана вызываемой функцией
function createTable302(rows, cols) {//объявляем функцию с 2 параметрами - строки, столбцы
	let table302 = document.createElement('table');//в переменную передаем таблицу
	for (let i = 1; i <= rows; i++) {// цикл гдк макс значение чило строк
	let tr = document.createElement('tr')//создем строки
		for (let j = 1; j <= cols; j++) {// цикл гдк макс значение чило столбцы
		let td = document.createElement('td'); //создем столбцы
		td.innerHTML = '1'//созданным тегам столбцов аередаем значения '1'
		tr.appendChild(td);//позиционируем тег td
		}
		table302.appendChild(tr);	//позиционируем тег tк
table302.style.color = 'red';		//навешиваем стиль таблице
	}
	return table302//результат исполнения функции
	}

// ______________________________
//303 Функция для создания таблицы из двухмерного массива

let div303 = document.querySelector('#elem303');//объявляем переменную передав ей тег дива
let arr303 = [[5, 9, 7], [6, 4, 2], [8, 8, 9]];//объявляем двумерный массиа

function createTableByArr303(arr303) {//объявляем функцию в параметр которого прописываем массив
let table = document.createElement('table')//создаем тег таблицы
for (let elem of arr303)//цикл по массиву
{ 
let tr = document.createElement('tr')//создаем тег строки таблицы
table.appendChild(tr);//позиционируем тег строки
for (let el of elem)//перебираем из одмассивов
{
let td = document.createElement('td'); //создаем тег столбцов (ячеек)
td.innerHTML = el //каждой ячейке присваиваем элемент из массива
tr.appendChild(td)//позиционируем тег столбца
}
}
return table//результат исполнения функции 
}
div303.appendChild(createTableByArr303(arr303))//позиционируем тег таблицы

// ______________________________
//304 Создание HTML таблицы из одномерного массива
let arr304 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];//объявляем массив
function convertArr304(arr304, cols304)//объявляем функцию с 2 переменными
{
let a304 = []//объявляем пустой массив
for (let i = 0; i < arr304.length; i+cols304)//объявляем цикл, где конечное значение - 
//длинна массива а шаг задается параметром функции
{
let del = arr304.splice(i, cols304);//в переменную передаем значение массива которое получается 
//от применения метода splice к массиву
console.log (del)//вывод в консоль
a304.push(del)//добавляем мвссивы в переменную с пустым массивом
}
console.log (a304)//вывод в консоль разделенных массивов

return a304//результат выводит новый массив

}
let m304 = convertArr304(arr304, 5)//в переменную передаем вызываемую функцию с параметрами - массив и кол во столбцов
let div304 = document.querySelector('#elem304');//в переменную передаем тег див
div304.innerHTML = m304;//значение тега див равен результату вызванной функции

// ______________________________
//305 Нехватка элементов в массиве при создании таблицы

//добавляем в массив новые элементы
//****************************************
let arr305 = [1, 2, 3, 4, 5, 6, 7, 8, 9];//объявляем переменную с массивом 
let cols305 = 3;//объявляем переменную, которая передает на сколько частей делится массив
function normalizeArr305(arr305, cols305, a305)//объявлям функцию с 3 параметрами - массив, шаг, пустой элемент
{
while (Number.isInteger(arr305.length/cols305) != true) // метод Number.isInteger -возвращает true если значение целое
	{
	arr305.push (a305)//метод push - добавляет в массив новый элемент со значением из параметра функции
	}
console.log (arr305)//вывод в консоль
return arr305//результат функции  - новый массив четный при делении элементов
}
let normalTwoDimArr305 = normalizeArr305(arr305, cols305, 0)//передаем в переменную вызываемую функцию с 3 параметрами
// массив, шаг , 0 - параметр чем заполнится если массив не четный, в переменной измененный массив

//добавляем в пустой массив поделенный массив
//********************************************* 
function convertArr305(arr305, cols305)//объявляем функцию с 2 параметрами 
{
let a305 = []//объявляем пустой массив
for (let i = 0; i < arr305.length; i+cols305)//объявляем цикл, где макс знач длинна массива, шаг берется из параметра
{
let del = arr305.splice(i, cols305);//в переменную передаем значение массива которое получается 
//от применения метода splice к массиву, разбивает массив на части
console.log (del)//вывод в консоль
a305.push(del)//добавляем обрезанные массивы в пустой массив
}
console.log (a305)//вывод в консоль
return a305//вывод пустого (уже заполненного ) при вызове функции
}
let twoDimArr305 = convertArr305(normalTwoDimArr305, cols305)//объявляем переменную куда передаем вызванную функцию convertArr305 с 2 параметрами

//перебираем двумерный массив, передавая его элементы в теги столбцов
//********************************************* 
let div305 = document.querySelector('#elem305');//объявляем див
function createTableByArr305(arr305) {//объявляем функцию с параметром - массив
let table = document.createElement('table')//метод createElement создает тег таблицы 
for (let elem of arr305)//цикл по двумерному массиву (находим строки)
{ 
let tr = document.createElement('tr')//создаем тег строки
table.appendChild(tr);//позиционируем строку
for (let el of elem)//цикл перебирающий подмассивы
{
let td = document.createElement('td'); //создаем тег ячейки
td.innerHTML = el//значение тега ячейки равен значению элемента подмассива
tr.appendChild(td)//позиционируем тег ячейки таблицы
}
}
return table//выводит таблицу 
}
div305.appendChild(createTableByArr305(twoDimArr305));//позиционируем таблицу

// ______________________________
//306 Конфликты переменных
//<script src="script.js"...
//тег script с атрибутом src определяет УРЛ внешнего файла со скриптом. Этот скрипт исполняется с приоритетом, даже если 
//будет иметься конфликт дубля (одинаково именованные переменные итд), этот скрипт будет исполнятся в приоритете. 

// ______________________________
//307 Модули через замыкания
//Описанная выше проблема характерна для любого языка программирования. В качестве решения применяют так называемые модули.
//Модуль представляет собой некую конструкцию, сделанную так, чтобы переменные и функции этой конструкции были видны только 
//внутри нее и не мешали никому снаружи. В JavaScript существуют несколько типов модулей. Самые простые модули через замыкания
// создаются с помощью вызова функции на месте, вот так:
//    ;(function() {
//      тут код модуля
//     })();

;(function() {//функциональное выражение в замыкание (снаружи окружена () и ; - разделитель с предыдущей строкой
	let str = 'переменная модуля';//переменной передаем строку
	//alert(str);//вывод строки

	function func() {//объявление функции 
		console.log('функция модуля');//вывод в консоль фразы
	}
	func()//вызов функции
})();////вызов функц выражения 
// Тут переменные и функции модуля недоступны:
//alert(str);
//alert(func);
//func()


;(function() {//функциональное выражение в замыкание (снаружи окружена () и ; - разделитель с предыдущей строкой
	let elem = document.querySelector('#div307_1'); // первый див
	
	function func(num) {//объявляем функцию с одним параметром 
		return num * num; // возведем в квадрат
	}
	
	elem.addEventListener('click', function() {//навешиваем на див событие клика
		this.innerHTML = func(elem.innerHTML);//значение дива равен результату исполнения функции
	});
})();
;(function() {//функциональное выражение в замыкание (снаружи окружена () и ; - разделитель с предыдущей строкой
	let elem = document.querySelector('#div307_2'); // второй див
	
	function func(num) {//объявляем функцию с одним параметром 
		return num * num * num; // возведем в куб
	}
	
	elem.addEventListener('click', function() {//навешиваем на див событие клика
		this.textContent = func(elem.textContent);//значение дива равен результату исполнения функции
	});
})();//вызов функц выражения 
//Теперь в каждом из модулей мы можем использовать любые переменные и функции, не боясь того, что они будут конфликтовать 
//с другими переменными и функциями нашего скрипта. Например, оба элемента мы храним в переменной elem - 
//каждый в своей переменной своего модуля. Если бы модулей здесь не было, пришлось бы вводить разные 
//переменные для хранения наши элементов. А с модулями мы можем спокойно использовать переменную elem, не боясь того,
//что кто-то захочет также использовать эту переменную. То же самое можно сказать и про функцию func - 
//в обоих модулях есть функция с таким именем и, если бы модулей не было, пришлось бы им давать разные имена.


// ______________________________
//308 Передача параметров в модуль через замыкания
//Хорошей практикой считается не зашивать какие-то значения в модуль, а передавать их параметром самого модуля 
//(то есть параметром вызывающейся на месте функции):
//;(function(arg1, arg2) { // параметры 
	//попадают в переменные 
//})(1, 2); // передаем какие-то параметры

;(function(selector1, selector2) {//замыкание с функциональным выражением, имеющий 2 параметра
	let div = document.querySelector(selector1);//объявляем переменную див
	let btn = document.querySelector(selector2);//объявляем переменную кнопку
	
	function func(num) {//объявляем функцию с переменной
		return num * num;//результат исполнения
	}
	btn.addEventListener('click', function() {//на кнопку навесим событие клика
		div.textContent = func(div.textContent);//метод textContent работает также как innerHTML
	});
})('#div308', '#btn308')//в параметры функционального выражения записываем id кнопки и области

// ______________________________
//309 Передача родительского элемента в модуль через замыкания

;(function(selector1, selector2, selector3, selector4, selector5) { //замыкание с функциональным выражением, имеющий 5 параметрами
	let div1 = document.querySelector(selector1);//передаем в переменную див
	let div2 = document.querySelector(selector2);//передаем в переменную див
	let div3 = document.querySelector(selector3);//передаем в переменную див
	let res  = document.querySelector(selector4);//передаем в переменную див
	let btn  = document.querySelector(selector5);//передаем в переменную кнопку
	
	btn.addEventListener('click', function() {//на кнопку навешиваем событие клика
		let num1 = Number(div1.textContent);//в переменную записываем значение divов
		let num2 = Number(div2.textContent);//в переменную записываем значение divов
		let num3 = Number(div3.textContent);//в переменную записываем значение divов
		
		res.textContent = num1 + num2 + num3;//значение res равна сумме переменных
	});
})('#div309_1', '#div309_2', '#div309_3', '#res309', '#btn309');//передаем в вызове функц выражения параметры

;(function(root) {//замыкание с функциональным выражением, имеющий 1 параметра
	let parent = document.querySelector(root);//в переменную записываем див родителя
	
	let div1 = parent.querySelector('#div3092_1');//в переменную передаем значение дива
	let div2 = parent.querySelector('#div3092_2');//в переменную передаем значение дива
	let div3 = parent.querySelector('#div3092_3');//в переменную передаем значение дива
	
	let res  = parent.querySelector('#res3092');//в переменную передаем значение дива
	let btn  = parent.querySelector('#btn3092');//в переменную передаем значение кнопки
	
	btn.addEventListener('click', function() {//на кнопку навешиваем событие клика
		let num1 = Number(div1.textContent);//в переменную записываем значение divов
		let num2 = Number(div2.textContent);//в переменную записываем значение divов
		let num3 = Number(div3.textContent);//в переменную записываем значение divов
		res.textContent = num1 + num2 + num3;//значение res равна сумме переменных
	});
})('#parent3092');//вызываем функц. выражение в параметр котрого передаем див родителя

// ______________________________
//310 Передача настроек модуля через замыкания
;(function(root, type, amount) {//объявляем функциональное выражение в замыкании 
	let parent = document.querySelector(root);//в переменную записываем значение тега название которого передасца из параметра функции
	
	for (let i = 1; i <= amount; i++) {//объявляем цикл макс значение которого передасца из параметра функционального выражения
		let elem = document.createElement(type);//создаем новый тег, название которого прописано в параметре функ. выражения
		elem.innerHTML = i //задаем значение новому тегу
		parent.appendChild(elem);//позиционируем новый тег методом appendChild родителя которого передаем через параметр функ. выражения
	}
})('#parent310_1', 'p', 7);//вызываем функциональное выражение, передавая параметры
//******************************************
let config310 = {//объявляем переменную куда передаем объект
	root:  '#parent310_2',//элементы объекта
	type:  'p',//элементы объекта
	amount: 5//элементы объекта
}
;(function(config310) {//объявляем функциональное выражение в замыкании 
	let parent = document.querySelector(config310.root);//в переменную записываем записываем значение тега полученного из объявленного объекта config310
	for (let i = 1; i <= config310.amount; i++) {//создаем цикл максимальное значение получаем из объекта
		let elem = document.createElement(config310.type);//создаем новый тег название которого получаем от объекта и передаем в переменную
			elem.innerHTML = i//новому тегу задаем значение 		
		parent.append(elem);//позицицонируем новый тег, родителя задаем через параметр функц. выражения 
	}
})(config310);//вызываем функциональное выражение в параметре которого объект
//******************************************
let config310_3 = {//объявляем объект 
	root:  '#parent310_3',//элементы объекта 
	amount: 10//элементы объекта 
}
;(function({root, type = 'p', amount = 5}) {//объявляем функциональное выражение с 3 параметрами имеющими знач по умолчанию
	let parent = document.querySelector(root);//объявляем переменную куда записывеми значение тега который получаем из параметров 
	for (let i = 1; i <= amount; i++) {//задаем цикл где макс значение задано параметром 
		let elem = document.createElement(type);//создаем тег где его название определяется параметром 
		elem.innerHTML = i//задаем значение нового тега 
		parent.append(elem);//позиционируем тег 
	}
})(config310_3);//передаем мпараметром в функциональное выражение объект

// ______________________________
//311 Экспорт переменных и функций в модулях через замыкания
//Иногда нужно сделать так, чтобы некоторые переменные и функции модуля были доступны снаружи
//Давайте экпортируем нашу функцию func. Для этого запишем ее в свойство встроенного в браузер объекта window:

;(function() {//объявление функционального выражения 
	function func() {//объявление функции 
		console.log('функция модуля');//вывод в консоль
	}
	
	window.f = func;//объект window.(любая переменная)  переносит функцмю за замыкание
})();
window.f(); // выведет функцию за замыкание которая выводит в консоль 'функция модуля'
f()//выведет функцию за замыкание которая выводит в консоль 'функция модуля'
//******************************************
;(function() {//функциональное выражение в замыкании
	function func1() {//объявление функции
		console.log('функция модуля1');//вывод в консоль
	}
	function func2() {//объявление функции
		console.log('функция модуля2');//вывод в консоль
	}
	function func3() {//объявление функции
		console.log('функция модуля3');//вывод в консоль
	}
	window.module = {func1: func1, func2: 
		func2, func3: func3};//объект window.(любая переменная)  переносит функцмю за замыкание
})();
module.func1()//выведет функцию за замыкание которая выводит в консоль 'функция модуля1'
module.func3()//выведет функцию за замыкание которая выводит в консоль 'функция модуля3'
module.func2()//выведет функцию за замыкание которая выводит в консоль 'функция модуля2'
//******************************************

;(function() {//функциональное выражение в замыкании
	let module = {};//создаем пустой объект
	
	module.func1 = function() {//заполняем объект, передаем в него элемент имеющее значение функцию
		console.log('функция модуля');
	}
	module.func2 = function() {//заполняем объект, передаем в него элемент имеющее значение функцию
		console.log('функция модуля');
	}
	module.func3 = function() {//заполняем объект, передаем в него элемент имеющее значение функцию
		console.log('функция модуля');
	}
	
	window.module = module;//объект window.(любая переменная)  переносит функцмю за замыкание 
})();
module.func1()//выведет функцию за замыкание которая объявлена в элементе объекта 'функция модуля'

// ______________________________
//312 Библиотеки через замыкания
//Часто в JavaScript создаются библиотеки, представляющие собой наборы функций для пользования другими программистами.
//Такие библиотеки обычно оборачиваются в модули через замыкания. Это делается для того, чтобы при подключении библиотеки 
//во внешнем мире появлялось как можно меньше функций.
//пишем все в <head>
//Подключим к ней нашу библиотеку: 	<script src="script.js">
//alert(math.avg([1, 2, 3]) + math.square());
	
</script>
	</body>
</html>